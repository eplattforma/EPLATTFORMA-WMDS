hat error is almost always frontend JavaScript calling response.json() while the server actually returned HTML, not JSON.

Unexpected token '<' is the giveaway: HTML responses typically start with <!doctype html> or <html>.

In your case, your UI is expecting a JSON payload (e.g., {success: true, ...}), but the clone endpoint is returning one of:

A login page / redirect HTML (session expired, not authorized, CSRF protection, etc.)

A Flask error page HTML (500)

A reverse-proxy timeout page HTML (502/504) because the clone takes too long

Below is the exact checklist I would give Replit to diagnose and fix it.

1) Confirm what the endpoint is actually returning (fastest way to pinpoint cause)

In the browser:

Open DevTools → Network

Click the request that triggers the clone (the POST to your “execute clone” endpoint)

Check:

Status code (200/302/401/403/500/502/504)

Response headers → Content-Type (application/json vs text/html)

Response body (you will literally see HTML if this is the issue)

Interpretations

302 → HTML: you are being redirected (often to /login), your fetch then tries to parse HTML as JSON.

401/403 → HTML: auth/permission failure returning an HTML page.

500 → HTML: backend error; Flask is returning an HTML error page.

502/504 → HTML: request timed out (very common for pg_dump/pg_restore via a web request).

2) Fix the frontend so it never “crashes” on non-JSON responses (critical)

In database_clone.html (or wherever the JS fetch lives), change the fetch handling like this:

async function readJsonOrText(response) {
  const contentType = response.headers.get("content-type") || "";
  const text = await response.text();

  if (contentType.includes("application/json")) {
    try {
      return { ok: response.ok, data: JSON.parse(text), raw: text };
    } catch (e) {
      return { ok: false, data: { success: false, error: "Invalid JSON from server" }, raw: text };
    }
  }

  // Non-JSON (HTML, plain text, proxy error page, etc.)
  return { ok: response.ok, data: { success: false, error: text }, raw: text };
}

async function runClone() {
  const res = await fetch("/admin/tools/database-clone/execute", {
    method: "POST",
    headers: { "X-Requested-With": "XMLHttpRequest" },
    // Usually not needed for same-origin, but safe:
    credentials: "same-origin",
  });

  const parsed = await readJsonOrText(res);

  if (!parsed.ok || !parsed.data.success) {
    // Show raw text in UI (truncate if huge)
    const msg = (parsed.data.error || parsed.raw || "Unknown error").slice(0, 5000);
    throw new Error(msg);
  }

  return parsed.data;
}


This immediately tells you whether the backend is returning login HTML, error HTML, or timeout HTML.

3) Fix the backend so the POST endpoint always returns JSON (even on errors)

Your clone POST endpoint should never render a template or redirect when called from JS.

Implement this pattern:

On success → return jsonify({...}), 200

On auth failure → return jsonify({...}), 401/403 (NOT redirect)

On exception → return jsonify({...}), 500 including stderr/stdout

Example:

from flask import jsonify, request
from flask_login import login_required, current_user

def json_error(message, status=400, **extra):
    payload = {"success": False, "error": message}
    payload.update(extra)
    return jsonify(payload), status

@bp_admin_tools.route("/admin/tools/database-clone/execute", methods=["POST"])
@login_required
def execute_database_clone():
    if current_user.role not in ["admin"]:
        return json_error("Access denied", status=403)

    try:
        # run clone logic...
        return jsonify({"success": True, "message": "Clone completed"}), 200

    except Exception as e:
        # include more structured details if you have them
        return json_error(str(e), status=500)


If you currently use @login_required and it redirects to HTML login page on unauthorized, your JS will get HTML. For API-like calls, you must return JSON.

4) If the status is 502/504: your clone is timing out (very likely)

A DB clone via pg_dump/pg_restore can take minutes. Many hosted/proxy setups kill requests around 30–60 seconds and return an HTML error page.

If DevTools shows 504 Gateway Timeout or similar, your long-term fix is:

Option A (recommended): “Job” approach (no timeouts)

POST /execute creates a db_clone_job row, returns {job_id}

Background thread/process runs the clone and streams logs into DB

UI polls /status?job_id=... every 1–2 seconds

This is the correct architecture for long-running tasks in web apps.

Option B: Don’t do it via web request

Run cloning from Replit Shell (manual) instead of through an admin page.

5) If the response is a login page (302/401/403): production secrets/session mismatch

Common causes on Replit:

You are not logged into the production domain (or session expired).

Cookies not being sent (cross-domain fetch).

Deployment environment does not have the same auth config.

CSRF protection rejects POST and returns HTML.

Fixes:

Ensure you are logged in to the same exact hostname you are calling.

Add credentials: "same-origin" in fetch.

If CSRF is enabled, include CSRF token header.

Ensure the route is protected with a decorator that returns JSON (not redirect).

6) If it’s 500: capture stderr/stdout from the clone command

Even if you fix JSON parsing, you still need the real error.

Ensure you capture and return:

returncode

stdout (truncated)

stderr (truncated)

If you’re using subprocess.run, do:

p = subprocess.run(cmd, shell=True, capture_output=True, text=True)
if p.returncode != 0:
    return json_error(
        "Database clone failed",
        status=500,
        returncode=p.returncode,
        stdout=p.stdout[-4000:],
        stderr=p.stderr[-4000:],
    )

The most likely root cause in practice

For DB cloning specifically, the top two real-world causes are:

Timeout / reverse proxy returns HTML (502/504)

Unauthorized/redirect to login HTML (302/401), especially if the admin tool uses login_required redirect behavior

If you do steps (1) + (2) above, you will immediately see which one it is, and you will also get the full HTML body to confirm.