1) What is implemented vs not (based on GitHub)
A) Backend clone endpoint exists and requires {confirmed: true}

Your backend clone route is clearly under:

GET /admin/tools/database-clone

POST /admin/tools/database-clone/execute

and it does require a JSON body with "confirmed": true (otherwise it returns an error). 
GitHub

✅ This matches your bullets:

“Added proper request body – includes {confirmed:true} as required by backend” (backend expects it)

B) “Enforced explicit DATABASE_URL_DEV (no fallback)” is NOT implemented

In routes_admin_tools.py the code still does:

database_url_dev = os.getenv("DATABASE_URL_DEV") or os.getenv("DATABASE_URL")

Meaning: if DATABASE_URL_DEV is missing, it will fall back to DATABASE_URL (dangerous—can overwrite the wrong DB). 
GitHub

❌ This does not match your bullet:

“Enforced explicit database URLs… no more fallback to DATABASE_URL”

C) “Better error diagnostics (stdout/stderr tail + return code)” is NOT implemented

The backend currently returns a generic error with str(e) and does not include:

return code

stdout tail

stderr tail

So if pg_dump/pg_restore fails, you still won’t see the real reason from the UI. 
GitHub

❌ This does not match your bullet:

“response now includes last 4000 characters of stdout/stderr + return code”

D) Frontend fixes: cannot confirm from the template you pointed to

Your templates/admin_tools/database_clone.html (as stored in GitHub) does not contain any JS fetch() logic and doesn’t show the execute URL usage in the file itself. 
GitHub

So I cannot confirm from that file that:

the frontend now calls /admin/tools/database-clone/execute

it sends {confirmed:true}

it checks content-type before parsing JSON

That said, your earlier symptom (“Unexpected token ‘<’”) is exactly what happens when the frontend calls an endpoint and receives HTML (404 page or login redirect) but still tries to parse JSON—so the fix you described is still the correct direction.

2) Why “Unexpected token ‘<’” (or “Unexpected token ‘I’ Internal S…”) happens

This is not “data volume”. It’s almost always one of these:

Wrong endpoint → 404 HTML page returned (starts with <html…)

Session expired → Flask-Login redirect to login HTML returned (<html…)

Unhandled server error → HTML error page returned (if not forced JSON)

Proxy / WAF / upstream returning non-JSON (can start with “Internal Server Error” text)

Your UI must either:

always hit the correct endpoint, and

never assume JSON unless content-type is JSON,
and your backend should ideally return JSON for XHR/API-style requests even on auth failure.

3) Concrete instructions for Replit to check & fix (copy/paste)
Step 1 — Find the place still calling the old endpoint

Run these in Replit shell:

grep -R "/admin/clone-database" -n .
grep -R "clone-database" -n templates static *.py
grep -R "database-clone/execute" -n templates static *.py


If anything still references /admin/clone-database, change it to:

POST /admin/tools/database-clone/execute

Step 2 — Standardize the frontend call (single source of truth)

Wherever the “Clone DB” button is, implement the call like this:

URL: /admin/tools/database-clone/execute

Method: POST

Body: {"confirmed": true}

Headers: Content-Type: application/json, Accept: application/json

Handle non-JSON safely

Example JS pattern (drop-in):

async function runDatabaseClone() {
  const res = await fetch("/admin/tools/database-clone/execute", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json"
    },
    body: JSON.stringify({ confirmed: true })
  });

  const ct = (res.headers.get("content-type") || "").toLowerCase();

  if (!ct.includes("application/json")) {
    const text = await res.text();
    throw new Error(`Server returned non-JSON (${res.status}). First 300 chars:\n${text.slice(0, 300)}`);
  }

  const data = await res.json();
  if (!res.ok || !data.success) {
    throw new Error(data.error || `Clone failed (HTTP ${res.status})`);
  }

  return data;
}

Step 3 — Fix the backend safety: require DATABASE_URL_DEV explicitly

In routes_admin_tools.py, change:

DATABASE_URL_DEV or DATABASE_URL (remove fallback)

Require all of:

DATABASE_URL_PROD

DATABASE_URL_DEV

and add a guard:

if PROD == DEV → refuse

if DEV contains prod host/name patterns → refuse

Step 4 — Add real diagnostics (without leaking secrets)

When subprocess fails, return:

returncode

stdout_tail (last 4000 chars)

stderr_tail (last 4000 chars)

Also sanitize URLs if you ever log them.

Step 5 — Improve auth failure behavior (prevents HTML responses)

Right now, if a session expires, Flask-Login often returns an HTML redirect. That recreates your JSON parse error.

Implement one of these:

Flask-Login unauthorized_handler that returns JSON when:

request path starts with /admin/tools/database-clone

OR request header includes Accept: application/json

That way the frontend always gets JSON errors for this action.

4) Additional reasons cloning can still fail (even after endpoint/JSON fixes)

These are the most common operational failures:

pg_dump / pg_restore not available in runtime (your code tries nix-shell, but the environment may differ)

Permission issues: prod role can’t read all schemas/tables; dev role can’t drop/create

Active connections to the DEV database prevent --clean drops

Extensions restore fails (role not allowed to create extension)

Timeouts / memory / disk (especially if DB is large)

If you implement stdout/stderr tail + return code, you will immediately know which of these it is.

Bottom line

From the GitHub code I can currently see:

✅ Backend endpoint exists and expects {confirmed:true} 
GitHub

❌ Backend still has DATABASE_URL fallback (unsafe) 
GitHub

❌ Backend does not yet return detailed stdout/stderr diagnostics 
GitHub

❓ Frontend endpoint + content-type handling: not verifiable from database_clone.html as stored 
GitHub

If you want, paste the exact error response you get now (status code + first ~300 characters of the response text), and I will tell you which of the remaining operational failure modes it is and what exact change to make next.