1) Add configurable defaults (top of main.py)

These can be changed later via Replit Secrets.

import os

# --- Defaults for NEW customers (override in Replit Secrets) ---
DEFAULT_TERMS_CODE = os.getenv("DEFAULT_TERMS_CODE", "COD")      # e.g., "COD" or "NET30"
DEFAULT_DUE_DAYS = int(os.getenv("DEFAULT_DUE_DAYS", "0"))       # 0 = COD
DEFAULT_IS_CREDIT = os.getenv("DEFAULT_IS_CREDIT", "false").lower() in ("1","true","yes","y")

DEFAULT_ALLOW_CASH = os.getenv("DEFAULT_ALLOW_CASH", "true").lower() in ("1","true","yes","y")
DEFAULT_ALLOW_CARD_POS = os.getenv("DEFAULT_ALLOW_CARD_POS", "true").lower() in ("1","true","yes","y")
DEFAULT_ALLOW_BANK_TRANSFER = os.getenv("DEFAULT_ALLOW_BANK_TRANSFER", "true").lower() in ("1","true","yes","y")
DEFAULT_ALLOW_CHEQUE = os.getenv("DEFAULT_ALLOW_CHEQUE", "false").lower() in ("1","true","yes","y")

DEFAULT_CHEQUE_DAYS_ALLOWED = os.getenv("DEFAULT_CHEQUE_DAYS_ALLOWED")  # "0","15","30" or None
DEFAULT_CREDIT_LIMIT = os.getenv("DEFAULT_CREDIT_LIMIT")                # "0" or None

2) Add a helper to create defaults (in main.py)

Put this below your SQLAlchemy setup (after Session = sessionmaker(...)) and import the models at top (from models import Customer, CreditTerms).

import datetime as dt

def _default_terms_values_for(code: str):
    return {
        "customer_code": code,
        "terms_code": DEFAULT_TERMS_CODE,
        "due_days": DEFAULT_DUE_DAYS,
        "is_credit": DEFAULT_IS_CREDIT,
        "credit_limit": (int(DEFAULT_CREDIT_LIMIT) if DEFAULT_CREDIT_LIMIT not in (None, "", "None") else None),
        "allow_cash": DEFAULT_ALLOW_CASH,
        "allow_card_pos": DEFAULT_ALLOW_CARD_POS,
        "allow_bank_transfer": DEFAULT_ALLOW_BANK_TRANSFER,
        "allow_cheque": DEFAULT_ALLOW_CHEQUE,
        "cheque_days_allowed": (int(DEFAULT_CHEQUE_DAYS_ALLOWED) if DEFAULT_CHEQUE_DAYS_ALLOWED not in (None, "", "None") else None),
        "valid_from": dt.date.today(),
        "notes_for_driver": None,
    }

3) (Recommended) DB-level auto-create using a SQLAlchemy event

This guarantees a default right when a Customer row is inserted, no matter who created it (order sync, batch import, etc.).

Add this in main.py after models are imported and the engine is created:

from sqlalchemy import event
from sqlalchemy.sql import text
from models import Customer, CreditTerms

@event.listens_for(Customer, "after_insert")
def _create_default_terms_after_customer_insert(mapper, connection, target: Customer):
    """
    Create a default active credit_terms row for the new customer
    IF there isn't already an active row (valid_to IS NULL).
    Uses a single SQL statement safe for SQLite/Postgres.
    """
    sql = text("""
        INSERT INTO credit_terms (
            customer_code, terms_code, due_days, is_credit,
            credit_limit, allow_cash, allow_card_pos, allow_bank_transfer, allow_cheque,
            cheque_days_allowed, notes_for_driver, valid_from, valid_to
        )
        SELECT
            :customer_code, :terms_code, :due_days, :is_credit,
            :credit_limit, :allow_cash, :allow_card_pos, :allow_bank_transfer, :allow_cheque,
            :cheque_days_allowed, :notes_for_driver, :valid_from, NULL
        WHERE NOT EXISTS (
            SELECT 1 FROM credit_terms
            WHERE customer_code = :customer_code AND valid_to IS NULL
        )
    """)
    params = _default_terms_values_for(target.code)
    params["customer_code"] = target.code
    connection.execute(sql, params)


Why this is best:

Runs automatically whenever a Customer is inserted.

Uses WHERE NOT EXISTS to avoid duplicates.

Works in SQLite (Replit) and Postgres the same way.

Note: If you have an import that creates an explicit terms version in the same transaction, you’ll end up with the default + your imported version. This is fine (you’ll have version history), but if you want to avoid the extra version, see the alternative below.

4) (Alternative) Application-level hook (no event)

If you prefer to avoid the ORM event, call this immediately after you insert any new Customer (e.g., in your order intake or customer sync):

def ensure_terms_for_customer(session, customer: Customer):
    active = (session.query(CreditTerms)
              .filter(CreditTerms.customer_code == customer.code, CreditTerms.valid_to.is_(None))
              .first())
    if active:
        return False
    session.add(CreditTerms(**_default_terms_values_for(customer.code)))
    return True


Use:

created = ensure_terms_for_customer(s, new_customer)

5) Safety net: one-click reconcile (optional)

In case you had customers before enabling this, add a reconcile endpoint to backfill defaults.

@app.post("/admin/credit-terms/reconcile")
def reconcile_missing_terms():
    s = Session()
    try:
        from sqlalchemy.sql import exists, and_
        created = 0
        for cust in s.query(Customer).all():
            has_active = s.query(exists().where(
                and_(CreditTerms.customer_code == cust.code, CreditTerms.valid_to.is_(None))
            )).scalar()
            if not has_active:
                s.add(CreditTerms(**_default_terms_values_for(cust.code)))
                created += 1
        s.commit()
        return {"status": "ok", "created_defaults": created}
    except Exception as e:
        s.rollback()
        return {"error": str(e)}, 500
    finally:
        s.close()

6) How to test on Replit

Run your repl.

Create a new customer anywhere in your code (e.g., a quick test route):

@app.post("/debug/new-customer")
def debug_new_customer():
    s = Session()
    try:
        from models import Customer
        code = request.args.get("code", "C999001")
        name = request.args.get("name", "Test Customer")
        c = Customer(code=code, name=name, group="Test")
        s.add(c)
        s.commit()
        return {"status": "customer_created", "code": code}
    except Exception as e:
        s.rollback()
        return {"error": str(e)}, 500
    finally:
        s.close()


Call POST /debug/new-customer?code=C999123&name=Demo

Hit your Payment Terms list page—customer will be there with default terms.

Edit in the Payment Terms management UI as normal.