import os
import logging
from datetime import datetime
from flask import render_template, redirect, url_for, flash, request, session, jsonify, current_app
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from werkzeug.security import check_password_hash, generate_password_hash
from werkzeug.utils import secure_filename
from urllib.parse import urlparse

import json
import re
from sqlalchemy import func

from app import app, db
from models import User, Invoice, InvoiceItem, PickingException, Setting, Shift, IdlePeriod, ActivityLog, BatchPickingSession, BatchSessionInvoice, StockPosition
from utils import create_user
from utils.invoice_utils import recalculate_invoice_totals
from utils.shift_tracking import (
    check_in_picker, check_out_picker, start_break, end_break, 
    record_activity, check_for_idle_pickers, check_for_missed_checkouts,
    admin_adjust_shift, get_active_shift, get_picker_on_break
)
from image_handler import get_product_image
from import_handler import process_excel_file
from timezone_utils import get_local_time, format_local_time, localize_datetime, get_local_now, get_utc_now, format_utc_datetime_to_local, utc_now_for_db
from utils.shipping_utils import get_ready_to_ship_orders, ship_invoices

# Register data warehouse blueprint
from datawarehouse_routes import dw_bp
app.register_blueprint(dw_bp)

# Register analytics blueprint
from dw_analytics_routes import analytics_bp
app.register_blueprint(analytics_bp)

from routes_admin_tools import bp as admin_tools_bp
app.register_blueprint(admin_tools_bp)


def validate_csrf_token():
    """CSRF token validation - tokens are generated by context processor"""
    if request.method == 'POST':
        # For AJAX requests, check X-CSRFToken header
        if request.is_json:
            token = request.headers.get('X-CSRFToken')
        else:
            # For form submissions, check csrf_token field
            token = request.form.get('csrf_token')
        
        # Get session token (should already exist from context processor)
        session_token = session.get('csrf_token')
        
        # Validate token - both token and session_token must exist and match
        if not token or not session_token or token != session_token:
            return False
    
    return True


def safe_redirect(url, fallback):
    """Validate URL for safe redirects to prevent open redirect attacks"""
    if not url:
        return redirect(fallback)
    
    parsed = urlparse(url)
    # Only allow relative URLs (no netloc) or same-host URLs
    if parsed.netloc and parsed.netloc != request.host:
        return redirect(fallback)
    
    return redirect(url)


def sort_items_by_config(items):
    """
    Sort items based on the configured sorting options in the admin settings.
    Also prioritizes regular items over skipped_pending items.
    
    Args:
        items: List of InvoiceItem objects to sort
        
    Returns:
        Sorted list of InvoiceItem objects with skipped items at the end
    """
    # Default sorting configuration
    default_sorting = {
        "zone": {"enabled": True, "order": 1, "direction": "asc", "manual_priority": []},
        "corridor": {"enabled": True, "order": 2, "direction": "asc"},
        "shelf": {"enabled": True, "order": 3, "direction": "asc"},
        "level": {"enabled": True, "order": 4, "direction": "asc"},
        "bin": {"enabled": True, "order": 5, "direction": "asc"}
    }
    
    # Get sorting configuration from database
    try:
        import json
        setting = Setting.query.filter_by(key='picking_sort_config').first()
        if setting:
            sorting_config = json.loads(setting.value)
        else:
            sorting_config = default_sorting
    except Exception:
        sorting_config = default_sorting
        
    # Split the items into regular and skipped_pending
    regular_items = [item for item in items if item.pick_status != 'skipped_pending']
    skipped_items = [item for item in items if item.pick_status == 'skipped_pending']
    
    def extract_location_parts(location):
        """Extract different parts from a location string like '20-05-B 03'
        
        Format: ZONE-CORRIDOR-SHELF LEVEL (e.g., '20-05-B 03')
        - Zone: 20 (first segment - the main area/aisle number)
        - Corridor: 05 (second segment - position within zone)
        - Shelf: B (letter part of third segment)
        - Level/Bin: 03 (number part of third segment)
        """
        if not location or location.lower() == 'none':
            return {'zone': '', 'corridor': '', 'shelf': '', 'level': '', 'bin': '', 'is_none': True}
        
        parts = {
            'zone': '',
            'corridor': '',
            'shelf': '',
            'level': '',
            'bin': '',
            'is_none': False
        }
        
        if '-' in location:
            segments = location.split('-')
            
            # First segment = Zone (e.g., '20' in '20-05-B 03')
            if len(segments) >= 1:
                parts['zone'] = segments[0].strip()
                
            # Second segment = Corridor (e.g., '05' in '20-05-B 03')
            if len(segments) >= 2:
                parts['corridor'] = segments[1].strip()
                
            # Third segment = Shelf + Level/Bin (e.g., 'B 03' or 'B03')
            if len(segments) >= 3:
                last_segment = segments[2].strip()
                
                import re
                # Match letter(s) then optional space then digits
                match = re.match(r'([A-Za-z]+)\s*(\d+)?', last_segment)
                if match:
                    shelf_letter, bin_number = match.groups()
                    parts['shelf'] = shelf_letter or ''
                    parts['level'] = shelf_letter or ''  # Level is the shelf letter
                    parts['bin'] = bin_number or ''
        else:
            parts['zone'] = location.strip()
            
        return parts
    
    def numeric_sort_key(value):
        """Create a sort key that properly handles numeric values within strings"""
        import re
        
        if not value:
            return ('', 0)  # Empty values sort first
            
        # Split the string into text and numeric parts
        parts = re.findall(r'(\d+|\D+)', value)
        
        # Convert numeric strings to integers for proper sorting
        result = []
        for part in parts:
            if part.isdigit():
                # Convert to integer for numeric comparison
                result.append(int(part))
            else:
                # Keep strings as strings
                result.append(part)
                
        # Convert result to a consistent format for comparison
        # Each element in the tuple must be comparable with elements of same index
        # in other tuples, so we need to ensure string-string and int-int comparisons
        final_result = []
        for i, item in enumerate(result):
            if isinstance(item, int):
                # All integers will be compared with integers
                final_result.append((1, item, ''))  # Type 1 = integer
            else:
                # All strings will be compared with strings
                final_result.append((0, 0, item))   # Type 0 = string
        
        return tuple(final_result)
    
    def get_sort_key(item):
        """Generate a sort key tuple based on configured sort order and enabled flags"""
        location = item.location or ''
        item_zone = item.zone or ''
        
        # Extract location parts
        parts = extract_location_parts(location)
        
        # If location is None/empty, sort last
        if parts.get('is_none', False):
            return ((999999,),)  # Very high value to sort last
        
        zone = parts['zone'] or ''
        corridor = parts['corridor'] or ''
        shelf = parts['shelf'] or ''
        level = parts['level'] or ''
        bin_val = parts['bin'] or ''
        
        # Get config for each field
        zone_config = sorting_config.get('zone', {})
        corridor_config = sorting_config.get('corridor', {})
        shelf_config = sorting_config.get('shelf', {})
        level_config = sorting_config.get('level', {})
        bin_config = sorting_config.get('bin', {})
        
        # Build list of (priority, field_name, key) for enabled fields only
        enabled_fields = []
        
        if zone_config.get('enabled', True):
            # Use zone from location parsing, fall back to item.zone
            effective_zone = zone if zone else (item_zone if item_zone else 'MAIN')
            manual_zones = zone_config.get('manual_priority', [])
            if manual_zones and effective_zone in manual_zones:
                zone_key = ((1, manual_zones.index(effective_zone), ''),)
            elif manual_zones:
                zone_key = ((1, len(manual_zones), ''),)
            else:
                zone_key = numeric_sort_key(effective_zone)
            enabled_fields.append((zone_config.get('order', 1), 'zone', zone_key))
        
        if corridor_config.get('enabled', True):
            enabled_fields.append((corridor_config.get('order', 2), 'corridor', numeric_sort_key(corridor)))
        
        if shelf_config.get('enabled', True):
            enabled_fields.append((shelf_config.get('order', 3), 'shelf', numeric_sort_key(shelf)))
        
        if level_config.get('enabled', True):
            enabled_fields.append((level_config.get('order', 4), 'level', numeric_sort_key(level)))
        
        if bin_config.get('enabled', True):
            enabled_fields.append((bin_config.get('order', 5), 'bin', numeric_sort_key(bin_val)))
        
        # Sort by priority order and build final key
        enabled_fields.sort(key=lambda x: x[0])
        sort_key = tuple(field[2] for field in enabled_fields)
        
        return sort_key if sort_key else (numeric_sort_key(location),)
    
    # Sort each group (regular items and skipped items) separately
    try:
        # Sort regular items by location
        sorted_regular_items = sorted(regular_items, key=get_sort_key)
        
        # Sort skipped items by location
        sorted_skipped_items = sorted(skipped_items, key=get_sort_key)
        
        # Return regular items first, then skipped items
        return sorted_regular_items + sorted_skipped_items
    except Exception as e:
        app.logger.error(f"Error sorting items: {str(e)}")
        # Fall back to unsorted items but still keep regular items first
        return regular_items + skipped_items


# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # type: ignore

# Add context processor to provide the 'now' datetime and CSRF token to all templates
@app.context_processor
def inject_context():
    # Ensure CSRF token exists in session
    if 'csrf_token' not in session:
        import secrets
        session['csrf_token'] = secrets.token_urlsafe(32)
    
    # Create csrf_token function for templates
    def csrf_token():
        return session.get('csrf_token', '')
    
    # Make use_shipments feature flag available to all templates
    use_shipments_raw = Setting.get(db.session, 'use_shipments', 'false')
    use_shipments = str(use_shipments_raw).strip().lower() in ('true', '1', 'yes', 'on')
    
    return {
        'now': get_local_time(),
        'csrf_token': csrf_token,
        'use_shipments': use_shipments
    }

# Template filter for timezone conversion
@app.template_filter('local_time')
def local_time_filter(dt):
    """Convert datetime to local timezone"""
    if dt is None:
        return ''
    return format_local_time(dt, '%Y-%m-%d %H:%M:%S')

@login_manager.user_loader
def load_user(username):
    user = User.query.get(username)
    # Return None if user is inactive, which will log them out
    if user and not user.is_active:
        return None
    return user

# Global shipment URL redirect handler
@app.before_request
def handle_shipment_urls():
    """Redirect shipment URLs when shipments feature is disabled"""
    # Skip if user is not authenticated
    if not current_user.is_authenticated:
        return None
    
    # Get current request path
    path = request.path
    
    # Check if this is a shipment-related URL
    shipment_paths = [
        '/shipments',
        '/orders/available',
        '/operations/shipments',
        '/api/shipments',
        '/api/orders/available'
    ]
    
    is_shipment_url = False
    
    # Check exact matches and prefix matches
    for shipment_path in shipment_paths:
        if path == shipment_path or path.startswith(shipment_path + '/'):
            is_shipment_url = True
            break
    
    # If not a shipment URL, proceed normally
    if not is_shipment_url:
        return None
    
    # Check if shipments feature is enabled
    try:
        use_shipments_raw = Setting.get(db.session, 'use_shipments', 'false')
        use_shipments = str(use_shipments_raw).strip().lower() in ('true', '1', 'yes', 'on')
        
        # If shipments are enabled, proceed normally
        if use_shipments:
            return None
        
        # Shipments are disabled - redirect to appropriate page
        flash('Shipment functionality is currently disabled. Redirected to available alternatives.', 'info')
        
        if current_user.role in ['admin', 'warehouse_manager']:
            # Redirect admins to ready to ship page as alternative
            return redirect(url_for('ready_to_ship'))
        else:
            # Redirect non-admins to their dashboard
            return redirect(url_for('picker_dashboard'))
            
    except Exception as e:
        # Log error and proceed normally to avoid breaking the app
        app.logger.error(f"Error checking shipments feature flag: {str(e)}")
        return None

# Health check endpoint for deployment (no database queries - responds fast)
@app.route('/health')
def health_check():
    """Lightweight health check endpoint for deployment health checks"""
    return {'status': 'healthy', 'service': 'picking-system'}, 200

# Login routes
@app.route('/')
def index():
    if current_user.is_authenticated:
        if current_user.role in ['admin', 'warehouse_manager']:
            return redirect(url_for('admin_dashboard'))
        elif current_user.role == 'driver':
            return redirect(url_for('driver.routes_list'))
        else:
            return redirect(url_for('picker_dashboard'))
    return redirect(url_for('login'))

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        if current_user.role in ['admin', 'warehouse_manager']:
            return redirect(url_for('admin_dashboard'))
        elif current_user.role == 'driver':
            return redirect(url_for('driver.routes_list'))
        else:
            return redirect(url_for('picker_dashboard'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        user = User.query.filter_by(username=username).first()
        
        if user and user.password is not None and password and check_password_hash(user.password, password):
            # Check if user account is active
            if not user.is_active:
                flash('Your account has been disabled. Please contact an administrator.', 'danger')
                return render_template('login.html')
            
            login_user(user)
            flash('Login successful!', 'success')
            
            if user.role in ['admin', 'warehouse_manager']:
                return redirect(url_for('admin_dashboard'))
            elif user.role == 'driver':
                return redirect(url_for('driver.routes_list'))
            else:
                return redirect(url_for('picker_dashboard'))
        else:
            flash('Invalid username or password', 'danger')
    
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'info')
    return redirect(url_for('login'))

@app.route('/change-password', methods=['GET', 'POST'])
@login_required
def change_password():
    """Allow users to change their own password"""
    if request.method == 'POST':
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        
        # Validate inputs
        if not current_password or not new_password or not confirm_password:
            flash('All fields are required.', 'danger')
            return render_template('change_password.html')
        
        if new_password != confirm_password:
            flash('New passwords do not match.', 'danger')
            return render_template('change_password.html')
        
        if len(new_password) < 4:
            flash('Password must be at least 4 characters long.', 'danger')
            return render_template('change_password.html')
        
        # Verify current password
        user = User.query.get(current_user.username)
        if not user or not check_password_hash(user.password, current_password):
            flash('Current password is incorrect.', 'danger')
            return render_template('change_password.html')
        
        # Update password
        user.password = generate_password_hash(new_password)
        db.session.commit()
        
        flash('Password changed successfully!', 'success')
        return redirect(url_for('picker_dashboard' if current_user.role == 'picker' else 'admin_dashboard'))
    
    return render_template('change_password.html')

@app.route('/admin/reset-password', methods=['GET', 'POST'])
@login_required
def admin_reset_password():
    """Allow admins to reset any user's password"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        target_username = request.form.get('target_username')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        
        # Validate inputs
        if not target_username or not new_password or not confirm_password:
            flash('All fields are required.', 'danger')
            return render_template('admin_reset_password.html')
        
        if new_password != confirm_password:
            flash('New passwords do not match.', 'danger')
            return render_template('admin_reset_password.html')
        
        if len(new_password) < 4:
            flash('Password must be at least 4 characters long.', 'danger')
            return render_template('admin_reset_password.html')
        
        # Find target user
        target_user = User.query.get(target_username)
        if not target_user:
            flash('User not found.', 'danger')
            return render_template('admin_reset_password.html')
        
        # Update password
        target_user.password = generate_password_hash(new_password)
        db.session.commit()
        
        # Log the activity
        activity = ActivityLog()
        activity.picker_username = current_user.username
        activity.activity_type = "admin_action"
        activity.timestamp = utc_now_for_db()
        activity.details = f"Admin {current_user.username} reset password for {target_username}"
        db.session.add(activity)
        db.session.commit()
        
        flash(f'Password for {target_username} has been reset successfully!', 'success')
        return redirect(url_for('admin_reset_password'))
    
    # Get all users for the dropdown
    users = User.query.all()
    # Check if a specific user was selected from the Users page
    selected_user = request.args.get('user')
    return render_template('admin_reset_password.html', users=users, selected_user=selected_user)

# Admin routes
@app.route('/admin')
@app.route('/admin/dashboard')
@login_required
def admin_dashboard():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get sorting parameters
    sort_by = request.args.get('sort', 'status')
    sort_dir = request.args.get('dir', 'asc')
    
    # Filter for open warehouse orders only (Not Started, Picking, Awaiting Batch Items, Awaiting Packing, Ready for Dispatch)
    # Exclude returned_to_warehouse - those orders should not appear on picking dashboard
    open_warehouse_statuses = ['not_started', 'picking', 'awaiting_batch_items', 'awaiting_packing', 'ready_for_dispatch']
    all_invoices = Invoice.query.filter(Invoice.status.in_(open_warehouse_statuses)).all()
    
    # Separate warehouse orders (not assigned to routes) from route-assigned orders
    # An invoice is assigned to a route if it has a route_id set
    warehouse_invoices = [inv for inv in all_invoices if not inv.route_id]
    route_assigned_invoices = [inv for inv in all_invoices if inv.route_id]
    
    # Define proper status sequence for sorting
    status_order = {
        'not_started': 0,
        'picking': 1,
        'awaiting_batch_items': 2,
        'awaiting_packing': 3,
        'ready_for_dispatch': 4,
        'shipped': 5,
        'delivered': 6,
        'delivery_failed': 6,
        'returned_to_warehouse': 7,
        'cancelled': 8
    }
    
    def multi_sort_key(invoice):
        # Primary sort: status
        status_priority = status_order.get(invoice.status, 999)
        
        # Secondary sort: routing number (as numeric, with empty values last)
        routing = invoice.routing
        if not routing or routing.strip() == '':
            routing_priority = (1, 999999)  # Empty values last
        else:
            try:
                # Try to convert to number for proper numeric sorting
                routing_num = float(routing.strip())
                routing_priority = (0, routing_num)
            except (ValueError, TypeError):
                # If not a number, sort as string but after numbers
                routing_priority = (0.5, routing.strip())
        
        return (status_priority, routing_priority)
    
    # Group route-assigned invoices by route_id
    route_groups = {}  # {route_id: [invoices]}
    unassigned_invoices = warehouse_invoices  # Warehouse invoices are already unassigned
    
    for inv in route_assigned_invoices:
        if inv.route_id:
            if inv.route_id not in route_groups:
                route_groups[inv.route_id] = []
            route_groups[inv.route_id].append(inv)
    
    # BATCH QUERY: Pre-fetch all RouteStop data for sorting
    from models import RouteStop
    stop_ids = [inv.stop_id for inv in route_assigned_invoices if inv.stop_id]
    route_stops_cache = {}
    if stop_ids:
        route_stops = RouteStop.query.filter(RouteStop.route_stop_id.in_(stop_ids)).all()
        for stop in route_stops:
            route_stops_cache[stop.route_stop_id] = stop
    
    # Sort invoices within each route group by stop sequence number
    for route_id in route_groups:
        def stop_sort_key(invoice):
            # Primary sort: stop sequence number (if assigned to a stop)
            if invoice.stop_id and invoice.stop_id in route_stops_cache:
                stop = route_stops_cache[invoice.stop_id]
                return (0, stop.seq_no, invoice.status, invoice.routing or '')
            # Invoices not assigned to stops go last
            return (1, 999999, invoice.status, invoice.routing or '')
        
        route_groups[route_id] = sorted(route_groups[route_id], key=stop_sort_key)
    
    # Sort unassigned invoices
    unassigned_invoices = sorted(unassigned_invoices, key=multi_sort_key)
    
    # Build final sorted list: route-assigned first, then unassigned
    invoices = []
    route_info = {}  # {route_id: route_object}
    
    # BATCH QUERY: Pre-fetch all Shipments for route sorting
    from models import Shipment
    route_ids = list(route_groups.keys())
    shipment_cache = {}
    if route_ids:
        shipments = Shipment.query.filter(Shipment.id.in_(route_ids)).all()
        for shipment in shipments:
            shipment_cache[shipment.id] = shipment
    
    # Add route-assigned invoices (sorted by route delivery date)
    def shipment_sort_key(rid):
        shipment = shipment_cache.get(rid)
        if shipment:
            return (shipment.delivery_date if shipment.delivery_date else datetime.max.date(), shipment.driver_name if shipment.driver_name else '')
        return (datetime.max.date(), '')
    
    sorted_route_ids = sorted(route_groups.keys(), key=shipment_sort_key)
    
    for route_id in sorted_route_ids:
        route = shipment_cache.get(route_id)
        if route:
            route_info[route_id] = route
        invoices.extend(route_groups[route_id])
    
    # Add unassigned invoices
    invoices.extend(unassigned_invoices)
    
    # Note: route_assigned_invoices are already grouped and sorted above
    
    # Filter completed invoices from both warehouse and route-assigned orders
    all_active_invoices = list(warehouse_invoices) + list(route_assigned_invoices)
    completed_invoices = [invoice for invoice in all_active_invoices if invoice.status == 'Completed']
    
    # Get all pickers
    pickers = User.query.filter_by(role='picker').all()
    
    # Get all drivers for route assignment
    drivers = User.query.filter_by(role='driver').all()
    
    # Get existing planned routes for route assignment
    from models import Shipment
    planned_routes = Shipment.query.filter_by(status='PLANNED').order_by(Shipment.delivery_date.desc(), Shipment.driver_name).all()
    
    # Create dictionaries to store additional information
    invoice_exceptions = {}     # Store exception counts
    batch_picked_info = {}      # Store batch picking information 
    picked_lines_count = {}     # Store count of picked lines
    total_lines_count = {}      # Store count of total lines
    picking_times = {}          # Store total picking time for completed orders
    
    # Import BatchPickedItem model to check for batch-picked items
    from models import BatchPickedItem, BatchPickingSession
    
    # BATCH QUERY 1: Get all exception counts for all invoices at once
    invoice_nos = [inv.invoice_no for inv in invoices]
    exception_counts = db.session.query(
        PickingException.invoice_no,
        func.count(PickingException.id).label('count')
    ).filter(PickingException.invoice_no.in_(invoice_nos)).group_by(PickingException.invoice_no).all()
    
    for invoice_no, count in exception_counts:
        invoice_exceptions[invoice_no] = count
    # Set 0 for invoices with no exceptions
    for invoice in invoices:
        if invoice.invoice_no not in invoice_exceptions:
            invoice_exceptions[invoice.invoice_no] = 0
    
    # BATCH QUERY 2: Get all items and their counts for all invoices at once
    all_items = InvoiceItem.query.filter(InvoiceItem.invoice_no.in_(invoice_nos)).all()
    items_by_invoice = {}
    for item in all_items:
        if item.invoice_no not in items_by_invoice:
            items_by_invoice[item.invoice_no] = []
        items_by_invoice[item.invoice_no].append(item)
    
    # NEW BATCH QUERY FOR PICKING TIMES: Get OrderTimeBreakdown and ItemTimeTracking data
    from models import OrderTimeBreakdown, ItemTimeTracking
    from timezone_utils import get_utc_now
    
    # Check if tables exist to prevent errors during migration/setup
    try:
        time_breakdowns = OrderTimeBreakdown.query.filter(
            OrderTimeBreakdown.invoice_no.in_(invoice_nos)
        ).all()
        breakdown_by_invoice = {tb.invoice_no: tb for tb in time_breakdowns}
        
        actual_tracking = db.session.query(
            ItemTimeTracking.invoice_no,
            func.sum(ItemTimeTracking.total_item_time).label('total_time')
        ).filter(
            ItemTimeTracking.invoice_no.in_(invoice_nos)
        ).group_by(ItemTimeTracking.invoice_no).all()
        actual_by_invoice = {t.invoice_no: t.total_time for t in actual_tracking}
    except Exception as e:
        import logging
        logging.error(f"Error fetching time tracking data: {e}")
        breakdown_by_invoice = {}
        actual_by_invoice = {}
    
    now_utc = get_utc_now()
    
    for invoice in invoices:
        items = items_by_invoice.get(invoice.invoice_no, [])
        total_lines_count[invoice.invoice_no] = len(items)
        picked_lines_count[invoice.invoice_no] = sum(1 for item in items if item.is_picked)
        
        # Calculate picking time with same logic as picker dashboard
        # Priority 1: Actual time from ItemTimeTracking
        actual_seconds = actual_by_invoice.get(invoice.invoice_no)
        if actual_seconds and actual_seconds > 0:
            picking_times[invoice.invoice_no] = f"{round(actual_seconds / 60, 2)}m"
        else:
            # Priority 2: Time from OrderTimeBreakdown
            breakdown = breakdown_by_invoice.get(invoice.invoice_no)
            if breakdown:
                if breakdown.picking_started and breakdown.picking_completed:
                    duration = (breakdown.picking_completed - breakdown.picking_started).total_seconds() / 60
                    picking_times[invoice.invoice_no] = f"{int(duration)}m"
                elif breakdown.picking_started and invoice.status == 'picking':
                    elapsed = (now_utc - breakdown.picking_started).total_seconds() / 60
                    picking_times[invoice.invoice_no] = f"{int(elapsed)}m"
            else:
                picking_times[invoice.invoice_no] = "â€”"
    
    # BATCH QUERY 3: Get all batch picked items and sessions for all invoices
    batch_items_list = BatchPickedItem.query.filter(BatchPickedItem.invoice_no.in_(invoice_nos)).all()
    batch_sessions_by_id = {}
    if batch_items_list:
        batch_ids = set(item.batch_session_id for item in batch_items_list)
        if batch_ids:
            batch_sessions = BatchPickingSession.query.filter(BatchPickingSession.id.in_(batch_ids)).all()
            for batch in batch_sessions:
                batch_sessions_by_id[batch.id] = batch
    
    # Group batch items by invoice
    batch_items_by_invoice = {}
    for batch_item in batch_items_list:
        if batch_item.invoice_no not in batch_items_by_invoice:
            batch_items_by_invoice[batch_item.invoice_no] = []
        batch_items_by_invoice[batch_item.invoice_no].append(batch_item)
    
    # Process batch picked info
    for invoice in invoices:
        batch_items = batch_items_by_invoice.get(invoice.invoice_no, [])
        if batch_items:
            batch_sessions = {}
            for batch_item in batch_items:
                batch_id = batch_item.batch_session_id
                if batch_id not in batch_sessions:
                    batch = batch_sessions_by_id.get(batch_id)
                    batch_name = batch.name if batch else f"Batch #{batch_id}"
                    batch_number = batch.batch_number if batch and batch.batch_number else f"BATCH-{batch_id}"
                    batch_sessions[batch_id] = {
                        "id": batch_id,
                        "name": batch_name,
                        "batch_number": batch_number,
                        "count": 0,
                        "items": []
                    }
                
                batch_sessions[batch_id]["count"] += 1
                # Get item name from cached items
                items_for_invoice = items_by_invoice.get(invoice.invoice_no, [])
                item = next((i for i in items_for_invoice if i.item_code == batch_item.item_code), None)
                if item:
                    batch_sessions[batch_id]["items"].append({
                        "code": item.item_code,
                        "name": item.item_name,
                        "qty": batch_item.picked_qty
                    })
            
            batch_picked_info[invoice.invoice_no] = batch_sessions
    
    # Calculate total remaining time for all warehouse orders
    total_remaining_time = 0
    for invoice in invoices:
        if invoice.status == 'not_started':
            # Add full expected time for not started orders
            total_remaining_time += (invoice.total_exp_time or 0)
        elif invoice.status == 'picking':
            # Add partial time for orders in progress
            picked_items = picked_lines_count.get(invoice.invoice_no, 0)
            total_items = total_lines_count.get(invoice.invoice_no, invoice.total_lines)
            if total_items > 0:
                remaining_percentage = ((total_items - picked_items) / total_items)
                remaining_time = (invoice.total_exp_time or 0) * remaining_percentage
                total_remaining_time += remaining_time
    
    # Get feature flags
    use_shipments_raw = Setting.get(db.session, 'use_shipments', 'false')
    use_shipments = str(use_shipments_raw).strip().lower() in ('true', '1', 'yes', 'on')
    
    # Get unresolved delivery issues count for warehouse managers
    unresolved_issues_count = 0
    if current_user.role == 'warehouse_manager':
        from models import DeliveryDiscrepancy
        unresolved_issues_count = DeliveryDiscrepancy.query.filter_by(is_resolved=False).count()
    
    # Get review-ready delivery issues count for admins
    review_issues_count = 0
    if current_user.role == 'admin':
        from models import DeliveryDiscrepancy
        review_issues_count = DeliveryDiscrepancy.query.filter_by(status='review').count()
    
    # Get stop sequence numbers for invoices (use cached RouteStop data)
    stop_sequences = {}  # {invoice_no: seq_no}
    for invoice in invoices:
        if invoice.stop_id and invoice.stop_id in route_stops_cache:
            stop = route_stops_cache[invoice.stop_id]
            stop_sequences[invoice.invoice_no] = stop.seq_no
    
    # Get active pickers with shift info
    active_pickers_data = []
    total_idle_time = 0
    active_shifts = Shift.query.filter_by(status='active').all()
    for shift in active_shifts:
        # Check for active breaks - most recent break without an end time
        on_break = db.session.query(IdlePeriod).filter(
            IdlePeriod.shift_id == shift.id,
            IdlePeriod.is_break == True,
            IdlePeriod.end_time.is_(None)
        ).order_by(IdlePeriod.start_time.desc()).first()
        
        # Calculate current idle time for this shift (only ongoing, not accumulated)
        shift_idle_time = shift.current_idle_minutes()
        total_idle_time += shift_idle_time
        
        from timezone_utils import get_utc_now, format_utc_datetime_to_local
        elapsed_minutes = int(((get_utc_now() - shift.check_in_time).total_seconds() / 60)) if shift.check_in_time else 0
        active_pickers_data.append({
            'username': shift.picker_username,
            'check_in_time': format_utc_datetime_to_local(shift.check_in_time, '%H:%M') if shift.check_in_time else '-',
            'elapsed_minutes': elapsed_minutes,
            'idle_time': shift_idle_time,
            'on_break': bool(on_break)
        })
    
    return render_template('admin_dashboard.html', 
                          invoices=invoices, 
                          completed_invoices=completed_invoices,
                          shipped_invoices=route_assigned_invoices,
                          pickers=pickers,
                          drivers=drivers,
                          planned_routes=planned_routes,
                          route_info=route_info,
                          invoice_exceptions=invoice_exceptions,
                          batch_picked_info=batch_picked_info,
                          picked_lines_count=picked_lines_count,
                          total_lines_count=total_lines_count,
                          picking_times=picking_times,
                          stop_sequences=stop_sequences,
                          current_time=get_local_time(),
                          total_remaining_time=total_remaining_time,
                          total_idle_time=total_idle_time,
                          sort_by=sort_by,
                          sort_dir=sort_dir,
                          use_shipments=use_shipments,
                          unresolved_issues_count=unresolved_issues_count,
                          review_issues_count=review_issues_count,
                          active_pickers_data=active_pickers_data)


@app.route('/ready-to-ship')
@login_required
def ready_to_ship():
    """Show orders ready to ship with Ship Now functionality"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get all ready to ship orders
    orders = get_ready_to_ship_orders()
    
    # CSRF token is now automatically generated by context processor
    return render_template('ready_to_ship.html', orders=orders)


@app.route('/orders/ship', methods=['POST'])
@login_required
def ship_single_order():
    """Ship a single order (form POST or AJAX)"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        if request.is_json:
            return jsonify({'error': 'Access denied. Admin privileges required.'}), 403
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # CSRF Protection
    if not validate_csrf_token():
        if request.is_json:
            return jsonify({'error': 'CSRF token validation failed'}), 403
        flash('Security error. Please try again.', 'danger')
        return redirect(url_for('ready_to_ship'))
    
    # Handle AJAX JSON request
    if request.is_json:
        try:
            data = request.get_json()
            invoice_no = data.get('invoice_no')
            if not invoice_no:
                return jsonify({'error': 'No invoice number provided'}), 400
            
            # Ship single order
            shipped, skipped, failed = ship_invoices([invoice_no], current_user.username)
            
            if shipped:
                return jsonify({
                    'success': True,
                    'message': f'Order {invoice_no} shipped successfully'
                })
            elif skipped:
                return jsonify({
                    'success': False,
                    'message': f'Order {invoice_no} was skipped (not ready for shipping)'
                })
            else:
                return jsonify({
                    'success': False,
                    'message': f'Failed to ship order {invoice_no}'
                })
                
        except Exception as e:
            app.logger.error(f"Error in single order shipping: {str(e)}")
            return jsonify({'error': f'Server error: {str(e)}'}), 500
    
    # Handle traditional form POST
    else:
        invoice_no = request.form.get('invoice_no')
        if not invoice_no:
            flash('No invoice number provided', 'danger')
            return redirect(url_for('ready_to_ship'))
        
        try:
            shipped, skipped, failed = ship_invoices([invoice_no], current_user.username)
            
            if shipped:
                flash(f'Order {invoice_no} shipped successfully', 'success')
            elif skipped:
                flash(f'Order {invoice_no} was skipped (not ready for shipping)', 'warning')
            else:
                flash(f'Failed to ship order {invoice_no}', 'danger')
                
        except Exception as e:
            app.logger.error(f"Error in single order shipping: {str(e)}")
            flash(f'Error shipping order: {str(e)}', 'danger')
        
        return redirect(url_for('ready_to_ship'))


@app.route('/orders/ship-bulk', methods=['POST'])
@login_required
def ship_orders_bulk():
    """Ship multiple orders via AJAX request"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        return jsonify({'error': 'Access denied. Admin privileges required.'}), 403
    
    # CSRF Protection
    if not validate_csrf_token():
        return jsonify({'error': 'CSRF token validation failed'}), 403
    
    try:
        data = request.get_json()
        if not data or 'invoice_numbers' not in data:
            return jsonify({'error': 'No invoice numbers provided'}), 400
        
        invoice_numbers = data['invoice_numbers']
        if not invoice_numbers or not isinstance(invoice_numbers, list):
            return jsonify({'error': 'Invalid invoice numbers format'}), 400
        
        # Ship the orders using the shipping utilities
        shipped, skipped, failed = ship_invoices(invoice_numbers, current_user.username)
        
        return jsonify({
            'success': True,
            'shipped': shipped,
            'skipped': skipped, 
            'failed': failed,
            'message': f'Processed {len(invoice_numbers)} orders: {len(shipped)} shipped, {len(skipped)} skipped, {len(failed)} failed'
        })
        
    except Exception as e:
        app.logger.error(f"Error in bulk shipping: {str(e)}")
        return jsonify({'error': f'Server error: {str(e)}'}), 500


@app.route('/orders/<invoice_no>/deliver', methods=['POST'])
@login_required
def mark_order_delivered(invoice_no):
    """Mark an order as delivered or delivery failed"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        if request.is_json:
            return jsonify({'error': 'Access denied. Admin privileges required.'}), 403
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # CSRF Protection
    if not validate_csrf_token():
        if request.is_json:
            return jsonify({'error': 'CSRF token validation failed'}), 403
        flash('Security error. Please try again.', 'danger')
        return safe_redirect(request.referrer, url_for('admin_dashboard'))
    
    from utils.shipping_utils import deliver_invoice
    
    # Handle AJAX JSON request
    if request.is_json:
        try:
            data = request.get_json()
            delivery_successful = data.get('successful', True)
            reason = data.get('reason', None)
            
            success = deliver_invoice(
                invoice_no=invoice_no,
                delivered_by=current_user.username,
                delivery_successful=delivery_successful,
                reason=reason
            )
            
            if success:
                status = 'delivered' if delivery_successful else 'delivery failed'
                return jsonify({
                    'success': True,
                    'message': f'Order {invoice_no} marked as {status}'
                })
            else:
                return jsonify({
                    'success': False,
                    'message': f'Failed to update delivery status for order {invoice_no}'
                })
                
        except Exception as e:
            app.logger.error(f"Error updating delivery status: {str(e)}")
            return jsonify({'error': f'Server error: {str(e)}'}), 500
    
    # Handle traditional form POST
    else:
        delivery_successful = request.form.get('successful', 'true') == 'true'
        reason = request.form.get('reason', None)
        
        try:
            success = deliver_invoice(
                invoice_no=invoice_no,
                delivered_by=current_user.username,
                delivery_successful=delivery_successful,
                reason=reason
            )
            
            if success:
                status = 'delivered' if delivery_successful else 'delivery failed'
                flash(f'Order {invoice_no} marked as {status}', 'success')
            else:
                flash(f'Failed to update delivery status for order {invoice_no}', 'danger')
                
        except Exception as e:
            app.logger.error(f"Error updating delivery status: {str(e)}")
            flash(f'Error updating delivery status: {str(e)}', 'danger')
        
        # Redirect back to appropriate page
        return safe_redirect(request.referrer, url_for('admin_dashboard'))

@app.route('/admin/clear_data', methods=['GET', 'POST'])
@login_required
def clear_data():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    try:
        # Import batch models here to avoid circular imports
        from models import BatchPickedItem, BatchSessionInvoice, BatchPickingSession
        
        # Delete data in the correct order to respect foreign key constraints
        
        # First, delete batch picking data
        app.logger.info("Clearing batch picking records...")
        db.session.query(BatchPickedItem).delete()
        db.session.query(BatchSessionInvoice).delete()
        db.session.query(BatchPickingSession).delete()
        
        # Delete activity logs referencing invoices
        app.logger.info("Clearing relevant activity logs...")
        db.session.query(ActivityLog).filter(ActivityLog.invoice_no.isnot(None)).delete()
        
        # Delete picking exceptions
        app.logger.info("Clearing picking exceptions...")
        db.session.query(PickingException).delete()
        
        # Delete item time tracking records
        app.logger.info("Clearing item time tracking...")
        from models import ItemTimeTracking
        db.session.query(ItemTimeTracking).delete()
        
        # Delete time tracking alerts that reference invoices
        app.logger.info("Clearing time tracking alerts...")
        from models import TimeTrackingAlert
        db.session.query(TimeTrackingAlert).delete()
        
        # Delete shipment-related data
        app.logger.info("Clearing route stop invoices...")
        from models import RouteStopInvoice, RouteStop, Shipment
        db.session.query(RouteStopInvoice).delete()
        
        app.logger.info("Clearing route stops...")
        db.session.query(RouteStop).delete()
        
        app.logger.info("Clearing shipments...")
        db.session.query(Shipment).delete()
        
        # Delete invoice items
        app.logger.info("Clearing invoice items...")
        db.session.query(InvoiceItem).delete()
        
        # Finally delete invoices
        app.logger.info("Clearing invoices...")
        db.session.query(Invoice).delete()
        
        db.session.commit()
        flash('All invoice data has been cleared successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error clearing data: {str(e)}")
        flash(f'Error clearing data: {str(e)}', 'danger')
    
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/import', methods=['GET', 'POST'])
@login_required
def import_excel():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Default file path for Excel import - check multiple locations
    default_file_paths = [
        r"C:\Dropbox\EPLATTFORMA SHARED FILES\EPLATTFORMA BI\WMS SYSTEM\Picking System Import.xlsx",
        "./Picking System Import.xlsx",  # Local copy in project root
        "./uploads/Picking System Import.xlsx"  # In uploads folder
    ]
    
    # Find the first existing file
    default_file_path = None
    for path in default_file_paths:
        if os.path.exists(path):
            default_file_path = path
            break
    
    # If no file found, use the primary path for display
    if not default_file_path:
        default_file_path = default_file_paths[0]
    
    if request.method == 'POST':
        # Check if we should use the default file path
        use_default_file = request.form.get('use_default_file')
        
        if use_default_file and default_file_path and os.path.exists(default_file_path):
            # Use the default file path
            logging.info(f"Using default file for import: {default_file_path}")
            try:
                success, message = process_excel_file(default_file_path, db.session)
                
                if success:
                    flash(f'Default file imported successfully: {message}', 'success')
                    logging.info(f"Default file import successful: {message}")
                else:
                    flash(f'Error importing default file: {message}', 'danger')
                    logging.error(f"Default file import failed: {message}")
                    
                return redirect(url_for('admin_dashboard'))
            except Exception as e:
                logging.error(f"Error processing default file: {str(e)}")
                flash(f'Error processing default file: {str(e)}', 'danger')
                return safe_redirect(request.url, url_for('import_excel'))
        elif use_default_file:
            # User tried to use default file but it doesn't exist
            flash('Default file not found. Please use manual upload instead.', 'warning')
            return safe_redirect(request.url, url_for('import_excel'))
        # File upload handling
        if 'file' not in request.files and not use_default_file:
            flash('No file part', 'danger')
            return safe_redirect(request.url, url_for('import_excel'))
        
        # Handle regular file upload if not using default file
        elif not use_default_file:
            file = request.files['file']
            if not file or file.filename == '':
                flash('No selected file', 'danger')
                return safe_redirect(request.url, url_for('import_excel'))
        
            if file and file.filename and file.filename.endswith('.xlsx'):
                try:
                    # Create a temporary filename with timestamp to avoid conflicts
                    import time
                    timestamp = int(time.time())
                    filename = f"import_{timestamp}_{secure_filename(str(file.filename))}"
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                    
                    # Make sure the upload folder exists
                    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
                    
                    # Save the file
                    file.save(filepath)
                    logging.info(f"File saved to {filepath}")
                    
                    # Process the file with try/except block
                    try:
                        # Process the Excel file with corridor extraction
                        success, message = process_excel_file(filepath, db.session)
                        
                        if success:
                            flash(f'File imported successfully: {message}', 'success')
                        else:
                            flash(f'Error importing file: {message}', 'danger')
                    except Exception as e:
                        logging.error(f"Error processing file: {str(e)}")
                        flash(f'Error processing file: {str(e)}', 'danger')
                    
                    # Keep the file for reference
                    # This helps avoid issues when importing large files
                    logging.info(f"Keeping imported file at {filepath} for reference")
                        
                    return redirect(url_for('admin_dashboard'))
                except Exception as e:
                    logging.error(f"File upload error: {str(e)}")
                    flash(f'Error uploading file: {str(e)}', 'danger')
                    return safe_redirect(request.url, url_for('import_excel'))
            else:
                flash('Invalid file format. Please upload an Excel file (.xlsx)', 'danger')
                return safe_redirect(request.url, url_for('import_excel'))
            
    # GET request - show the form
    logging.info(f"Import page accessed - default_file_path: {default_file_path}")
    logging.info(f"File exists: {default_file_path and os.path.exists(default_file_path)}")
    
    return render_template('import_excel.html', 
                         default_file_path=default_file_path,
                         default_file_exists=default_file_path and os.path.exists(default_file_path))

@app.route('/admin/sync-customers', methods=['POST'])
@login_required
def sync_ps365_customers():
    """Trigger PS365 customer sync from admin interface"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    try:
        from services_powersoft import sync_active_customers
        result = sync_active_customers()
        
        if result.get('success'):
            flash(f'âœ… Customer sync completed! {result["updated_count"]} customers synced from PS365.', 'success')
        else:
            flash(f'âŒ Customer sync failed: {result.get("error", "Unknown error")}', 'danger')
    except Exception as e:
        app.logger.error(f"Customer sync error: {str(e)}")
        flash(f'âŒ Customer sync error: {str(e)}', 'danger')
    
    return redirect(url_for('import_excel'))

@app.route('/admin/import-invoices', methods=['GET'])
@login_required
def import_invoices_page():
    """Show invoice import page"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    return render_template('admin_import_invoices.html')

@app.route('/admin/assign', methods=['POST'])
@login_required
def assign_picker():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice_no = request.form.get('invoice_no')
    picker_username = request.form.get('picker_username')
    
    if not invoice_no or not picker_username:
        flash('Missing required information', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    invoice = Invoice.query.get(invoice_no)
    if not invoice:
        flash(f'Invoice {invoice_no} not found', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    picker = User.query.filter_by(username=picker_username, role='picker').first()
    if not picker:
        flash(f'Picker {picker_username} not found', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    invoice.assigned_to = picker.username
    db.session.commit()
    
    flash(f'Invoice {invoice_no} assigned to {picker_username}', 'success')
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/unassign', methods=['POST'])
@login_required
def unassign_picker():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice_no = request.form.get('invoice_no')
    
    if not invoice_no:
        flash('Missing required information', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    invoice = Invoice.query.get(invoice_no)
    if not invoice:
        flash(f'Invoice {invoice_no} not found', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    invoice.assigned_to = None
    db.session.commit()
    
    flash(f'Invoice {invoice_no} unassigned', 'success')
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/autocomplete_order', methods=['POST'])
@login_required
def autocomplete_order():
    """Admin function to automatically complete an order by marking all items as picked"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice_no = request.form.get('invoice_no')
    
    if not invoice_no:
        flash('Missing required information', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    invoice = Invoice.query.get(invoice_no)
    if not invoice:
        flash(f'Invoice {invoice_no} not found', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    # Check if order is already completed
    if invoice.status in ['ready_for_dispatch', 'shipped', 'delivered']:
        flash(f'Invoice {invoice_no} is already completed', 'warning')
        return redirect(url_for('admin_dashboard'))
    
    try:
        # Get all unpicked items for this invoice
        unpicked_items = InvoiceItem.query.filter_by(
            invoice_no=invoice_no, 
            is_picked=False
        ).all()
        
        if not unpicked_items:
            flash(f'All items in invoice {invoice_no} are already picked', 'info')
            return redirect(url_for('admin_dashboard'))
        
        items_completed = 0
        items_skipped_batch = 0
        
        # Mark all unpicked items as picked with full quantity
        for item in unpicked_items:
            # Check if item is locked by batch - skip if locked
            if item.locked_by_batch_id:
                items_skipped_batch += 1
                continue
                
            item.is_picked = True
            item.picked_qty = item.qty  # Pick full quantity
            item.pick_status = 'picked'
            
            # Create minimal time tracking record for the autocompleted item
            from models import ItemTimeTracking
            from timezone_utils import get_utc_now
            tracking = ItemTimeTracking()
            tracking.invoice_no = invoice_no
            tracking.item_code = item.item_code
            tracking.picker_username = current_user.username
            tracking.item_started = get_utc_now()
            tracking.item_completed = get_utc_now()
            tracking.walking_time = 0  # Autocompleted - no actual time
            tracking.picking_time = 0  # Autocompleted - no actual time
            tracking.confirmation_time = 0  # Autocompleted - no actual time
            tracking.was_skipped = False
            tracking.picked_correctly = True
            tracking.skip_reason = "Admin autocompleted"
            
            db.session.add(tracking)
            items_completed += 1
        
        # Log the admin activity
        activity = ActivityLog()
        activity.picker_username = current_user.username
        activity.activity_type = 'admin_action'
        activity.timestamp = utc_now_for_db()
        activity.invoice_no = invoice_no
        activity.details = f'Admin {current_user.username} autocompleted {items_completed} items in order {invoice_no}'
        db.session.add(activity)
        
        # Update invoice completion timestamps and set to ready_for_dispatch (packing included)
        invoice.picking_complete_time = utc_now_for_db()
        invoice.packing_complete_time = utc_now_for_db()
        invoice.current_item_index = invoice.total_lines
        invoice.status = 'ready_for_dispatch'
        
        db.session.commit()
        
        # Create success message
        message = f'Successfully autocompleted {items_completed} items in invoice {invoice_no}'
        if items_skipped_batch > 0:
            message += f' ({items_skipped_batch} items skipped - locked by batch)'
        message += f'. Order status: ready_for_dispatch'
        
        flash(message, 'success')
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Error autocompleting order {invoice_no}: {str(e)}')
        flash(f'Error autocompleting order {invoice_no}: {str(e)}', 'danger')
    
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/users', methods=['GET', 'POST'])
@login_required
def manage_users():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        role = request.form.get('role')
        
        if not username or not password or not role:
            flash('All fields are required', 'danger')
            return redirect(url_for('manage_users'))
        
        success, message = create_user(db.session, username, password, role)
        
        if success:
            flash(f'User {username} created successfully', 'success')
        else:
            flash(message, 'danger')
            
        return redirect(url_for('manage_users'))
    
    # Get filter parameter (default to 'all')
    status_filter = request.args.get('filter', 'all')
    
    # Query users based on filter
    if status_filter == 'active':
        users = User.query.filter_by(is_active=True).all()
    elif status_filter == 'inactive':
        users = User.query.filter_by(is_active=False).all()
    else:
        users = User.query.all()
    
    return render_template('users.html', users=users, status_filter=status_filter)

@app.route('/admin/users/<username>/edit', methods=['POST'])
@login_required
def edit_user(username):
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    user = User.query.get_or_404(username)
    
    new_username = request.form.get('username')
    new_role = request.form.get('role')
    payment_type_code_365 = request.form.get('payment_type_code_365', '').strip() or None
    require_gps_check = request.form.get('require_gps_check') == 'on'
    
    if not new_username or not new_role:
        flash('Username and role are required', 'danger')
        return redirect(url_for('manage_users'))
    
    # Check if username already exists (and it's not the current user)
    if new_username != username:
        existing_user = User.query.filter_by(username=new_username).first()
        if existing_user:
            flash(f'Username {new_username} already exists', 'danger')
            return redirect(url_for('manage_users'))
    
    old_username = user.username
    
    # If username is changing, we need to delete and recreate due to primary key
    if new_username != old_username:
        # Create new user with new username
        new_user = User()  # type: ignore
        new_user.username = new_username
        new_user.password = user.password
        new_user.role = new_role
        new_user.payment_type_code_365 = payment_type_code_365
        new_user.require_gps_check = require_gps_check
        db.session.delete(user)
        db.session.add(new_user)
    else:
        # Just update role, payment code, and GPS setting
        user.role = new_role
        user.payment_type_code_365 = payment_type_code_365
        user.require_gps_check = require_gps_check
    
    try:
        db.session.commit()
        if new_username != old_username:
            flash(f'User {old_username} updated successfully to {new_username} with role {new_role}', 'success')
        else:
            flash(f'User {old_username} updated successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating user: {str(e)}', 'danger')
    
    return redirect(url_for('manage_users'))

@app.route('/admin/users/<username>/delete', methods=['POST'])
@login_required
def delete_user(username):
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    user = User.query.filter_by(username=username).first_or_404()
    
    # Prevent deleting yourself
    if user.username == current_user.username:
        flash('You cannot delete your own account', 'danger')
        return redirect(url_for('manage_users'))
    
    try:
        db.session.delete(user)
        db.session.commit()
        flash(f'User {username} deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting user: {str(e)}', 'danger')
    
    return redirect(url_for('manage_users'))

@app.route('/admin/users/<username>/toggle-status', methods=['POST'])
@login_required
def toggle_user_status(username):
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    user = User.query.filter_by(username=username).first_or_404()
    
    # Prevent disabling yourself
    if user.username == current_user.username:
        flash('You cannot disable your own account', 'danger')
        return redirect(url_for('manage_users'))
    
    try:
        if user.is_active:
            # Disable the user
            reason = request.form.get('reason', 'Disabled by admin')
            user.disable(reason=reason)
            flash(f'User {username} has been disabled', 'success')
        else:
            # Enable the user
            user.enable()
            flash(f'User {username} has been enabled', 'success')
        
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating user status: {str(e)}', 'danger')
    
    return redirect(url_for('manage_users'))

@app.route('/admin/sorting', methods=['GET', 'POST'])
@login_required
def admin_sorting_settings():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Default sorting configuration
    default_sorting = {
        "zone": {"enabled": True, "order": 1, "direction": "asc", "manual_priority": []},
        "corridor": {"enabled": True, "order": 2, "direction": "asc"},
        "shelf": {"enabled": True, "order": 3, "direction": "asc"},
        "level": {"enabled": True, "order": 4, "direction": "asc"},
        "bin": {"enabled": True, "order": 5, "direction": "asc"}
    }
    
    if request.method == 'POST':
        # Build the new sorting configuration from form data
        new_sorting = {}
        
        # Get all sort parameters
        for field in ['zone', 'corridor', 'shelf', 'level', 'bin']:
            enabled = request.form.get(f'{field}_enabled') == 'on'
            order = int(request.form.get(f'{field}_order', 0))
            direction = request.form.get(f'{field}_direction', 'asc')
            
            new_sorting[field] = {
                "enabled": enabled,
                "order": order,
                "direction": direction
            }
            
            # Special handling for zone manual priority
            if field == 'zone':
                manual_priority = request.form.get('zone_manual_priority', '')
                manual_priority_list = [p.strip() for p in manual_priority.split(',') if p.strip()]
                new_sorting[field]['manual_priority'] = manual_priority_list
        
        # Save the configuration to the database
        try:
            import json
            setting = Setting.query.filter_by(key='picking_sort_config').first()
            if setting:
                setting.value = json.dumps(new_sorting)
            else:
                setting = Setting()
                setting.key = 'picking_sort_config'
                setting.value = json.dumps(new_sorting)
                db.session.add(setting)
            db.session.commit()
            flash('Sorting settings updated successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error saving sorting settings: {str(e)}', 'danger')
        
        return redirect(url_for('admin_sorting_settings'))
    
    # Get current sorting configuration
    try:
        import json
        setting = Setting.query.filter_by(key='picking_sort_config').first()
        if setting:
            sorting_config = json.loads(setting.value)
        else:
            sorting_config = default_sorting
    except Exception:
        sorting_config = default_sorting
    
    # Convert manual priority list to comma-separated string for display
    if 'zone' in sorting_config and 'manual_priority' in sorting_config['zone']:
        manual_priority_str = ', '.join(sorting_config['zone']['manual_priority'])
    else:
        manual_priority_str = ''
    
    return render_template('admin_sorting.html', 
                          sorting_config=sorting_config,
                          manual_priority_str=manual_priority_str)

@app.route('/admin/settings', methods=['GET', 'POST'])
@login_required
def admin_settings():
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        confirm_picking = request.form.get('confirm_picking_step', 'true')
        show_image = request.form.get('show_image_on_picking_screen', 'true')
        show_multi_qty_warning = request.form.get('show_multi_qty_warning', 'true')
        # Batch picking setting removed - will be rebuilt
        require_skip_reason = request.form.get('require_skip_reason', 'true')
        skip_reasons = request.form.get('skip_reasons', '')
        exception_reasons = request.form.get('exception_reasons', '')
        receiving_notes = request.form.get('receiving_notes', '')
        
        # Time tracking alert settings
        alerts_enabled = request.form.get('time_alerts_enabled', 'false') == 'true'
        warning_threshold = float(request.form.get('warning_threshold', '120'))
        critical_threshold = float(request.form.get('critical_threshold', '150'))
        auto_notify_admin = request.form.get('auto_notify_admin', 'false') == 'true'
        show_picker_warnings = request.form.get('show_picker_warnings', 'false') == 'true'
        
        # Helper function to save settings
        def save_setting(key, value):
            setting = Setting.query.filter_by(key=key).first()
            if setting:
                setting.value = value
            else:
                setting = Setting()
                setting.key = key
                setting.value = value
                db.session.add(setting)
        
        # Save time tracking alert settings
        from time_alerts import update_alert_settings
        alert_settings = {
            'enabled': alerts_enabled,
            'warning_threshold': warning_threshold,
            'critical_threshold': critical_threshold,
            'auto_notify_admin': auto_notify_admin,
            'show_picker_warnings': show_picker_warnings
        }
        update_alert_settings(alert_settings)
        
        # Save all settings
        save_setting('confirm_picking_step', confirm_picking)
        save_setting('show_image_on_picking_screen', show_image)
        save_setting('show_multi_qty_warning', show_multi_qty_warning)
        # Batch picking setting save removed - will be rebuilt
        save_setting('require_skip_reason', require_skip_reason)
        save_setting('skip_reasons', skip_reasons)
        save_setting('exception_reasons', exception_reasons)
        save_setting('receiving_notes', receiving_notes)
        
        db.session.commit()
        flash('Settings updated successfully', 'success')
        return redirect(url_for('admin_settings'))
    
    # Get current settings
    confirm_picking = Setting.get(db.session, 'confirm_picking_step', 'true')
    show_image = Setting.get(db.session, 'show_image_on_picking_screen', 'true')
    show_multi_qty_warning = Setting.get(db.session, 'show_multi_qty_warning', 'true')
    # Batch picking setting removed - will be rebuilt
    require_skip_reason = Setting.get(db.session, 'require_skip_reason', 'true')
    
    # Get the skip reasons or provide defaults if not set
    default_skip_reasons = "Need assistance\nLocation not accessible\nNeed equipment\nNeed to check with supervisor\nOther"
    skip_reasons = Setting.get(db.session, 'skip_reasons', default_skip_reasons)
    
    # Get the exception reasons or provide defaults if not set
    default_exception_reasons = "Item not found\nInsufficient quantity\nDamaged product\nWrong location\nOther"
    exception_reasons = Setting.get(db.session, 'exception_reasons', default_exception_reasons)
    
    # Get the receiving notes or provide defaults if not set
    default_receiving_notes = "Wrong Barcode\nBarcode not in system\nNew Product\nRepacking\nNeeds Labels"
    receiving_notes = Setting.get(db.session, 'receiving_notes', default_receiving_notes)
    
    # Get current alert settings for display
    from time_alerts import get_alert_settings
    alert_settings = get_alert_settings()
    
    return render_template('admin_settings.html', 
                         confirm_picking=confirm_picking, 
                         show_image=show_image,
                         show_multi_qty_warning=show_multi_qty_warning,
                         # Batch picking template parameter removed - will be rebuilt
                         require_skip_reason=require_skip_reason,
                         skip_reasons=skip_reasons,
                         exception_reasons=exception_reasons,
                         receiving_notes=receiving_notes,
                         alert_settings=alert_settings)

@app.route('/admin/discrepancy-config', methods=['GET', 'POST'])
@login_required
def admin_discrepancy_config():
    """Admin page for managing discrepancy types and stock resolutions"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    from models import DiscrepancyType, StockResolution
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add_discrepancy_type':
            name = request.form.get('name', '').strip().lower().replace(' ', '_')
            display_name = request.form.get('display_name', '').strip()
            
            if name and display_name:
                existing = DiscrepancyType.query.filter_by(name=name).first()
                if existing:
                    flash(f'Discrepancy type "{name}" already exists', 'warning')
                else:
                    max_order = db.session.query(db.func.max(DiscrepancyType.sort_order)).scalar() or 0
                    new_type = DiscrepancyType()
                    new_type.name = name
                    new_type.display_name = display_name
                    new_type.is_active = True
                    new_type.sort_order = max_order + 1
                    db.session.add(new_type)
                    db.session.commit()
                    flash(f'Added discrepancy type: {display_name}', 'success')
        
        elif action == 'toggle_discrepancy_type':
            type_id = request.form.get('type_id')
            discrepancy_type = DiscrepancyType.query.get(type_id)
            if discrepancy_type:
                discrepancy_type.is_active = not discrepancy_type.is_active
                db.session.commit()
                status = 'activated' if discrepancy_type.is_active else 'deactivated'
                flash(f'Discrepancy type {discrepancy_type.display_name} {status}', 'success')
        
        elif action == 'delete_discrepancy_type':
            type_id = request.form.get('type_id')
            discrepancy_type = DiscrepancyType.query.get(type_id)
            if discrepancy_type:
                StockResolution.query.filter_by(discrepancy_type=discrepancy_type.name).delete()
                db.session.delete(discrepancy_type)
                db.session.commit()
                flash(f'Deleted discrepancy type: {discrepancy_type.display_name}', 'success')
        
        elif action == 'add_resolution':
            discrepancy_type = request.form.get('discrepancy_type')
            resolution_name = request.form.get('resolution_name', '').strip()
            
            if discrepancy_type and resolution_name:
                max_order = db.session.query(db.func.max(StockResolution.sort_order)).filter_by(
                    discrepancy_type=discrepancy_type
                ).scalar() or 0
                
                new_resolution = StockResolution()
                new_resolution.discrepancy_type = discrepancy_type
                new_resolution.resolution_name = resolution_name
                new_resolution.is_active = True
                new_resolution.sort_order = max_order + 1
                db.session.add(new_resolution)
                db.session.commit()
                flash(f'Added resolution: {resolution_name}', 'success')
        
        elif action == 'toggle_resolution':
            resolution_id = request.form.get('resolution_id')
            resolution = StockResolution.query.get(resolution_id)
            if resolution:
                resolution.is_active = not resolution.is_active
                db.session.commit()
                status = 'activated' if resolution.is_active else 'deactivated'
                flash(f'Resolution {resolution.resolution_name} {status}', 'success')
        
        elif action == 'delete_resolution':
            resolution_id = request.form.get('resolution_id')
            resolution = StockResolution.query.get(resolution_id)
            if resolution:
                db.session.delete(resolution)
                db.session.commit()
                flash(f'Deleted resolution: {resolution.resolution_name}', 'success')
        
        return redirect(url_for('admin_discrepancy_config'))
    
    discrepancy_types = DiscrepancyType.query.order_by(DiscrepancyType.sort_order).all()
    
    resolutions_by_type = {}
    for dtype in discrepancy_types:
        resolutions_by_type[dtype.name] = StockResolution.query.filter_by(
            discrepancy_type=dtype.name
        ).order_by(StockResolution.sort_order).all()
    
    return render_template('admin_discrepancy_config.html',
                         discrepancy_types=discrepancy_types,
                         resolutions_by_type=resolutions_by_type)

@app.route('/admin/sql-console', methods=['GET', 'POST'])
@login_required
def admin_sql_console():
    """Temporary admin SQL console for running database queries"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    results = None
    error = None
    query = ''
    
    if request.method == 'POST':
        query = request.form.get('sql_query', '').strip()
        
        if query:
            try:
                from sqlalchemy import text
                result = db.session.execute(text(query))
                
                # Check if this is a SELECT query (returns rows)
                if query.upper().startswith('SELECT'):
                    rows = result.fetchall()
                    if rows:
                        # Get column names
                        columns = list(rows[0]._mapping.keys())
                        # Convert rows to list of dicts
                        results = [dict(row._mapping) for row in rows]
                    else:
                        results = []
                        columns = []
                    
                    flash(f'Query returned {len(results)} rows', 'success')
                else:
                    # For INSERT, UPDATE, DELETE
                    db.session.commit()
                    flash('Query executed successfully', 'success')
                    results = {'message': 'Query executed successfully'}
                    
            except Exception as e:
                db.session.rollback()
                error = str(e)
                flash(f'Error: {error}', 'danger')
    
    # Provide helpful pre-written queries
    sample_queries = {
        'preview_test_invoices': "SELECT invoice_no, status, assigned_to FROM invoices WHERE LOWER(invoice_no) LIKE '%test%' LIMIT 20;",
        'count_test_invoices': "SELECT COUNT(*) as count FROM invoices WHERE LOWER(invoice_no) LIKE '%test%';",
        'delete_test_items': "DELETE FROM invoice_items WHERE invoice_no IN (SELECT invoice_no FROM invoices WHERE LOWER(invoice_no) LIKE '%test%');",
        'delete_test_exceptions': "DELETE FROM picking_exceptions WHERE invoice_no IN (SELECT invoice_no FROM invoices WHERE LOWER(invoice_no) LIKE '%test%');",
        'delete_test_activities': "DELETE FROM activity_logs WHERE invoice_no IN (SELECT invoice_no FROM invoices WHERE LOWER(invoice_no) LIKE '%test%');",
        'delete_test_tracking': "DELETE FROM item_time_tracking WHERE invoice_no IN (SELECT invoice_no FROM invoices WHERE LOWER(invoice_no) LIKE '%test%');",
        'delete_test_invoices': "DELETE FROM invoices WHERE LOWER(invoice_no) LIKE '%test%';"
    }
    
    return render_template('admin_sql_console.html', 
                         results=results, 
                         error=error,
                         query=query,
                         sample_queries=sample_queries)

@app.route('/admin/time-alerts')
@login_required
def admin_time_alerts():
    """Admin dashboard for viewing and managing time tracking alerts"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    from time_alerts import get_active_alerts, get_alert_settings
    from models import TimeTrackingAlert
    
    # Get active alerts
    active_alerts = get_active_alerts()
    
    # Get resolved alerts from last 7 days
    from datetime import datetime, timedelta
    week_ago = datetime.now() - timedelta(days=7)
    resolved_alerts = TimeTrackingAlert.query.filter(
        TimeTrackingAlert.is_resolved == True,
        TimeTrackingAlert.resolved_at >= week_ago
    ).order_by(TimeTrackingAlert.resolved_at.desc()).limit(20).all()
    
    # Get alert settings
    alert_settings = get_alert_settings()
    
    return render_template('admin_time_alerts.html',
                         active_alerts=active_alerts,
                         resolved_alerts=resolved_alerts,
                         alert_settings=alert_settings)

@app.route('/admin/time-alerts/<int:alert_id>/resolve', methods=['POST'])
@login_required
def resolve_time_alert(alert_id):
    """Resolve a time tracking alert"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    from time_alerts import resolve_alert
    notes = request.form.get('notes', '')
    
    if resolve_alert(alert_id, current_user.username, notes):
        flash('Alert resolved successfully.', 'success')
    else:
        flash('Failed to resolve alert.', 'danger')
    
    return redirect(url_for('admin_time_alerts'))

@app.route('/admin/view_exceptions/<invoice_no>')
@login_required
def admin_view_exceptions(invoice_no):
    """View exceptions for a specific invoice"""
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get the invoice
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Get all exceptions for this invoice
    exceptions = PickingException.query.filter_by(invoice_no=invoice_no).order_by(PickingException.timestamp.desc()).all()
    
    # Get invoice items for reference
    items = InvoiceItem.query.filter_by(invoice_no=invoice_no).all()
    
    # Create a lookup dictionary for easier access to item details
    item_lookup = {item.item_code: item for item in items}
    
    return render_template('admin_view_exceptions.html', 
                          invoice=invoice, 
                          exceptions=exceptions,
                          item_lookup=item_lookup)

@app.route('/admin/corrections', methods=['GET', 'POST'])
@login_required
def admin_corrections():
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get all users for the picker filter dropdown
    users = User.query.all()
    
    # Check if specific invoices were selected (from POST)
    selected_invoice_nos = None
    if request.method == 'POST':
        selected_invoice_nos = request.form.getlist('invoice_nos[]')
    
    # Apply filters from request args
    invoice_filter = request.args.get('invoice_no', '')
    picker_filter = request.args.get('picker', '')
    status_filter = request.args.get('status', '')
    customer_filter = request.args.get('customer_name', '')
    
    # Start with invoices, use eager loading for relationships to avoid N+1 queries
    from sqlalchemy.orm import joinedload
    query = Invoice.query.options(
        joinedload(Invoice.items),  # type: ignore
        joinedload(Invoice.exceptions)  # type: ignore
    ).filter(
        Invoice.invoice_no.like('IN1%')  # Only production invoices (exclude test data)
    )
    
    # If specific invoices were selected, filter by those
    if selected_invoice_nos:
        query = query.filter(Invoice.invoice_no.in_(selected_invoice_nos))
    else:
        # Apply other filters only if no specific invoices selected
        if invoice_filter:
            query = query.filter(Invoice.invoice_no.like(f'%{invoice_filter}%'))
        
        if picker_filter:
            query = query.filter(Invoice.assigned_to == picker_filter)
        
        if status_filter:
            query = query.filter(Invoice.status == status_filter)
        
        if customer_filter:
            query = query.filter(Invoice.customer_name.like(f'%{customer_filter}%'))
    
    # Sort by date descending (newest first), then invoice number descending
    query = query.order_by(
        db.func.to_date(Invoice.upload_date, 'YYYY-MM-DD').desc(),
        Invoice.invoice_no.desc()
    )
    
    # Limit to 100 most recent invoices if no specific invoices or filters applied
    if not selected_invoice_nos and not (invoice_filter or picker_filter or status_filter or customer_filter):
        query = query.limit(100)
    
    # Get results
    invoices = query.all()
    
    return render_template('admin_corrections.html', 
                          invoices=invoices, 
                          users=users)

@app.route('/admin/invoice/<invoice_no>')
@login_required
def admin_view_invoice(invoice_no):
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get invoice and associated data
    invoice = Invoice.query.get_or_404(invoice_no)
    exceptions = PickingException.query.filter_by(invoice_no=invoice_no).all()
    
    # Apply custom sorting to the invoice items
    sorted_items = sort_items_by_config(invoice.items)
    
    # Get routing history
    from models import InvoiceRouteHistory, DeliveryDiscrepancy, CODReceipt, PODRecord
    routing_history = InvoiceRouteHistory.query.filter_by(
        invoice_no=invoice_no
    ).order_by(InvoiceRouteHistory.created_at.desc()).all()
    
    # Get delivery events from invoice_delivery_events table (raw SQL)
    delivery_events_sql = db.session.execute(
        db.text("""
            SELECT timestamp, action, actor, reason
            FROM invoice_delivery_events
            WHERE invoice_no = :invoice_no
            ORDER BY timestamp DESC
        """),
        {"invoice_no": invoice_no}
    ).fetchall()
    
    # Convert to dict-like objects for template
    delivery_events = []
    for event in delivery_events_sql:
        delivery_events.append({
            'timestamp': event[0],
            'action': event[1],
            'actor': event[2],
            'reason': event[3]
        })
    
    # Get delivery discrepancies (exceptions during delivery)
    delivery_discrepancies = DeliveryDiscrepancy.query.filter_by(
        invoice_no=invoice_no
    ).order_by(DeliveryDiscrepancy.reported_at.desc()).all()
    
    # Get COD receipts (payment records) - invoice_nos is JSON array
    from sqlalchemy import cast, String
    cod_receipts = CODReceipt.query.filter(
        cast(CODReceipt.invoice_nos, String).like(f'%"{invoice_no}"%')
    ).order_by(CODReceipt.created_at.desc()).all()
    
    # Get POD records (proof of delivery) - invoice_nos is JSON array
    pod_records = PODRecord.query.filter(
        cast(PODRecord.invoice_nos, String).like(f'%"{invoice_no}"%')
    ).order_by(PODRecord.collected_at.desc()).all()
    
    # Import the helper function to get product images
    from utils.image_handler import get_product_image
    
    return render_template('admin_view_invoice.html', 
                          invoice=invoice, 
                          items=sorted_items,
                          exceptions=exceptions,
                          routing_history=routing_history,
                          delivery_events=delivery_events,
                          delivery_discrepancies=delivery_discrepancies,
                          cod_receipts=cod_receipts,
                          pod_records=pod_records,
                          get_product_image=get_product_image)

@app.route('/admin/invoice/<invoice_no>/update', methods=['POST'])
@login_required
def admin_update_invoice_items(invoice_no):
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Process each item in the invoice
    for item in invoice.items:
        # Get form values for this item
        status = request.form.get(f'is_picked_{item.item_code}', 'not_picked')
        picked_qty = int(request.form.get(f'picked_qty_{item.item_code}', 0))
        
        # Update the item based on status
        if status == 'not_picked':
            item.is_picked = False
            item.picked_qty = None
            item.pick_status = 'not_picked'
        elif status == 'reset':
            item.is_picked = False
            item.picked_qty = None
            item.pick_status = 'reset'
            item.reset_by = current_user.username
            item.reset_timestamp = utc_now_for_db()
            item.reset_note = "Reset by administrator"
        elif status == 'exception':
            item.is_picked = True
            item.picked_qty = picked_qty
            item.pick_status = 'exception'
        else:
            item.is_picked = True
            item.picked_qty = picked_qty
            item.pick_status = 'picked'
    
    # Recalculate invoice totals
    recalculate_invoice_totals(db.session, invoice_no)
    
    # Update invoice status intelligently based on the new status system
    # Only update status if the order is in early stages (not_started, picking, ready_for_dispatch)
    # Don't touch orders that are shipped, out_for_delivery, delivered, etc.
    all_picked = all(item.is_picked for item in invoice.items)
    
    if invoice.status in ['not_started', 'picking']:
        # Early stage orders - update to ready_for_dispatch if all picked
        if all_picked:
            invoice.status = 'ready_for_dispatch'
        elif invoice.status == 'not_started':
            # If some items are picked, move to picking state
            if any(item.is_picked for item in invoice.items):
                invoice.status = 'picking'
    elif invoice.status == 'ready_for_dispatch':
        # If ready_for_dispatch but items are un-picked, move back to picking
        if not all_picked:
            invoice.status = 'picking'
        # Otherwise preserve ready_for_dispatch status (don't downgrade it)
    # For shipped, out_for_delivery, delivered, etc. - preserve the status
    # Admins correcting quantities shouldn't change delivery status
    
    db.session.commit()
    flash('Invoice items updated successfully', 'success')
    return redirect(url_for('admin_view_invoice', invoice_no=invoice_no))

@app.route('/admin/invoice/<invoice_no>/reset-progress')
@login_required
def admin_reset_invoice_progress(invoice_no):
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Reset all items
    for item in invoice.items:
        item.is_picked = False
        item.picked_qty = None
        item.pick_status = 'reset'
        item.reset_by = current_user.username
        item.reset_timestamp = utc_now_for_db()
        item.reset_note = "Full invoice reset by administrator"
    
    # Reset invoice progress
    invoice.current_item_index = 0
    invoice.status = 'In Progress'
    
    # Recalculate invoice totals
    recalculate_invoice_totals(db.session, invoice_no)
    
    db.session.commit()
    flash('Invoice progress has been reset. All items are now marked as Not Picked.', 'success')
    return redirect(url_for('admin_view_invoice', invoice_no=invoice_no))

@app.route('/admin/invoice/<invoice_no>/item/<item_code>/reset')
@login_required
def admin_reset_item(invoice_no, item_code):
    # Only admin users can access this page
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Find the specific item
    item = None
    for i in invoice.items:
        if i.item_code == item_code:
            item = i
            break
    
    if not item:
        flash('Item not found', 'danger')
        return redirect(url_for('admin_view_invoice', invoice_no=invoice_no))
    
    # Reset the specific item
    item.is_picked = False
    item.picked_qty = None
    item.pick_status = 'reset'
    item.reset_by = current_user.username
    item.reset_timestamp = utc_now_for_db()
    
    # Get reset note if provided
    reset_note = request.args.get('reset_note')
    if reset_note:
        item.reset_note = reset_note
    
    # Adjust invoice progress if needed
    # For in-progress invoices, we need to ensure they can pick this item again
    if invoice.status == 'In Progress':
        # Find the item's position in the list using custom sorting configuration
        items = sort_items_by_config(invoice.items)
        item_index = items.index(item)
        
        # If the current index is past this item, move it back
        if invoice.current_item_index > item_index:
            invoice.current_item_index = item_index
    
    # If the invoice was complete and we're un-picking an item, update status
    if invoice.status == 'Completed':
        invoice.status = 'In Progress'
    
    # Check if we need to update status based on picked items
    picked_items_count = sum(1 for item in invoice.items if item.is_picked)
    
    # Update status based on picked items count
    if picked_items_count == 0:
        # No items picked - set to "not_started"
        invoice.status = 'not_started'
        invoice.current_item_index = 0
    elif picked_items_count < len(invoice.items):
        # Some items picked but not all - set to "picking"
        invoice.status = 'picking'
    
    # Recalculate invoice totals
    recalculate_invoice_totals(db.session, invoice_no)
    
    # Add a note in the request form if provided
    note = request.args.get('reset_note')
    if note:
        # Could save to a notes table if needed
        pass
    
    db.session.commit()
    flash(f'Item {item_code} has been reset and is now available for picking again.', 'success')
    return redirect(url_for('admin_view_invoice', invoice_no=invoice_no))

# Picker routes
@app.route('/picker/dashboard')
@login_required
def picker_dashboard():
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Get all invoices assigned to this picker that still need picking/packing
    # Picker-visible statuses: not_started, picking, awaiting_batch_items, awaiting_packing
    # Once an order reaches 'ready_for_dispatch', the picker's job is complete
    invoices = Invoice.query.filter_by(assigned_to=current_user.username).filter(
        Invoice.status.in_(['not_started', 'picking', 'awaiting_batch_items', 'awaiting_packing'])
    ).all()
    
    # Calculate picking times for invoices using OrderTimeBreakdown and ItemTimeTracking
    from models import OrderTimeBreakdown, ItemTimeTracking
    picking_times = {}
    
    # Get all relevant invoices for time calculation (including those on admin dashboard)
    # The current code only does this for invoices assigned to the current user (picker dashboard)
    # We need to do this for all invoices being displayed on both dashboards
    all_visible_invoices = invoices if 'invoices' in locals() else []
    if 'all_invoices' in locals():
        all_visible_invoices = all_invoices
        
    invoice_nos = [inv.invoice_no for inv in all_visible_invoices]
    time_breakdowns = OrderTimeBreakdown.query.filter(
        OrderTimeBreakdown.invoice_no.in_(invoice_nos)
    ).all()
    breakdown_by_invoice = {tb.invoice_no: tb for tb in time_breakdowns}
    
    # Get item tracking aggregates for "Actual" time
    from sqlalchemy import func
    actual_tracking = db.session.query(
        ItemTimeTracking.invoice_no,
        func.sum(ItemTimeTracking.total_item_time).label('total_time')
    ).filter(
        ItemTimeTracking.invoice_no.in_(invoice_nos)
    ).group_by(ItemTimeTracking.invoice_no).all()
    actual_by_invoice = {t.invoice_no: t.total_time for t in actual_tracking}
    
    from timezone_utils import get_utc_now
    now_utc = get_utc_now()
    
    for invoice in all_visible_invoices:
        # Priority 1: Actual time from ItemTimeTracking
        actual_seconds = actual_by_invoice.get(invoice.invoice_no)
        if actual_seconds and actual_seconds > 0:
            picking_times[invoice.invoice_no] = f"{round(actual_seconds / 60, 2)}m"
            continue
            
        # Priority 2: Time from OrderTimeBreakdown
        breakdown = breakdown_by_invoice.get(invoice.invoice_no)
        if breakdown:
            if breakdown.picking_started and breakdown.picking_completed:
                duration = (breakdown.picking_completed - breakdown.picking_started).total_seconds() / 60
                picking_times[invoice.invoice_no] = f"{int(duration)}m"
            elif breakdown.picking_started and invoice.status == 'picking':
                elapsed = (now_utc - breakdown.picking_started).total_seconds() / 60
                picking_times[invoice.invoice_no] = f"{int(elapsed)}m"
    
    # Get batch picking sessions assigned to this picker (include today's completed ones)
    from datetime import date
    today = date.today()
    
    from sqlalchemy import or_, and_, func
    batch_sessions = BatchPickingSession.query.filter_by(
        assigned_to=current_user.username
    ).filter(
        or_(
            BatchPickingSession.status.in_(['Active', 'Paused']),
            and_(
                BatchPickingSession.status == 'Completed',
                func.date(BatchPickingSession.created_at) == today
            )
        )
    ).all()
    
    # Process batch sessions to include summary information
    batch_data = []
    for batch in batch_sessions:
        # Get invoices in this batch
        batch_invoices = BatchSessionInvoice.query.filter_by(batch_session_id=batch.id).all()
        invoice_count = len(batch_invoices)
        
        # Handle both active and completed batches
        if batch.status == 'Completed':
            # For completed batches, count items that were actually in the batch
            batch_zones = [zone.strip() for zone in batch.zones.split(',') if zone.strip()]
            batch_corridors = []
            if batch.corridors:
                batch_corridors = [corridor.strip() for corridor in batch.corridors.split(',') if corridor.strip()]
            
            total_items = 0
            completed_items = 0
            
            for bi in batch_invoices:
                invoice = Invoice.query.get(bi.invoice_no)
                if invoice:
                    items = InvoiceItem.query.filter_by(invoice_no=invoice.invoice_no).all()
                    for item in items:
                        if item.zone in batch_zones:
                            if not batch_corridors or item.corridor in batch_corridors:
                                if item.locked_by_batch_id == batch.id:
                                    total_items += 1
                                    if item.is_picked:
                                        completed_items += 1
        else:
            # For active batches, use the filtered count method
            total_items = batch.get_filtered_item_count()
            completed_items = 0
            
            # Count completed items using the same filtering logic
            batch_zones = [zone.strip() for zone in batch.zones.split(',') if zone.strip()]
            batch_corridors = []
            if batch.corridors:
                batch_corridors = [corridor.strip() for corridor in batch.corridors.split(',') if corridor.strip()]
            
            for bi in batch_invoices:
                invoice = Invoice.query.get(bi.invoice_no)
                if invoice:
                    items = InvoiceItem.query.filter_by(invoice_no=invoice.invoice_no).all()
                    
                    for item in items:
                        if item.zone in batch_zones:
                            if not batch_corridors or item.corridor in batch_corridors:
                                # Only count if item is available to this batch (not locked by others)
                                if item.locked_by_batch_id is None or item.locked_by_batch_id == batch.id:
                                    if item.is_picked:
                                        completed_items += 1
        
        batch_data.append({
            'session': batch,
            'invoice_count': invoice_count,
            'total_items': total_items,
            'completed_items': completed_items,
            'progress_percent': (completed_items / total_items * 100) if total_items > 0 else 0
        })
    
    # Sort batch data: completed batches last, then by creation date (newest first within each status)
    def batch_sort_key(batch_data):
        batch = batch_data['session']
        # Primary sort: status (completed batches last)
        status_priority = 0 if batch.status != 'Completed' else 1
        # Secondary sort: creation date (newest first)
        creation_date_priority = -batch.created_at.timestamp()
        return (status_priority, creation_date_priority)
    
    batch_data.sort(key=batch_sort_key)
    
    # Get active shift for this picker
    active_shift = get_active_shift(current_user.username)
    
    # Check if the picker is on break
    on_break = get_picker_on_break(current_user.username)
    
    # Record the activity for idle detection if user has an active shift
    if active_shift:
        record_activity(current_user.username, 'screen_interaction', 
                       details='Viewing picker dashboard')
    
    # Get unvalidated delivery issues count for this picker
    from models import DeliveryDiscrepancy
    picker_unvalidated_issues_count = DeliveryDiscrepancy.query.filter_by(
        picker_username=current_user.username,
        is_validated=False
    ).count()
    
    # Calculate shift duration properly with timezone handling
    # Times are stored in UTC, calculate using UTC
    from timezone_utils import get_utc_now, format_utc_datetime_to_local as format_time
    shift_duration_minutes = 0
    check_in_time_formatted = None
    on_break_start_time_formatted = None
    
    if active_shift:
        now_utc = get_utc_now()  # Get current UTC time
        # Calculate elapsed using UTC times
        shift_duration_minutes = int((now_utc - active_shift.check_in_time).total_seconds() / 60)
        # Format check-in time for display in Athens timezone
        check_in_time_formatted = format_time(active_shift.check_in_time, '%H:%M') if active_shift.check_in_time else None
    
    if on_break:
        on_break_start_time_formatted = format_time(on_break.start_time, '%H:%M') if on_break.start_time else None
    
    return render_template('picker_dashboard.html', 
                          invoices=invoices,
                          batch_sessions=batch_data,
                          active_shift=active_shift,
                          on_break=on_break,
                          check_in_time_formatted=check_in_time_formatted,
                          on_break_start_time_formatted=on_break_start_time_formatted,
                          shift_duration_minutes=shift_duration_minutes,
                          picker_unvalidated_issues_count=picker_unvalidated_issues_count,
                          picking_times=picking_times)

# Batch picking dashboard removed - will be rebuilt

@app.route('/picker/invoice/<invoice_no>/start')
@login_required
def start_picking(invoice_no):
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Check if picker has an active shift
    active_shift = get_active_shift(current_user.username)
    if not active_shift:
        flash('You must check in for a shift before picking.', 'warning')
        return redirect(url_for('shift_check_in'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Verify this picker is assigned to this invoice
    if invoice.assigned_to != current_user.username:
        flash('You are not assigned to this invoice.', 'danger')
        return redirect(url_for('picker_dashboard'))
    
    # Update status to picking if not already
    if invoice.status == 'not_started':
        invoice.status = 'picking'
        invoice.current_item_index = 0
        
        # Log the actual start time for picking
        from models import ActivityLog
        start_log = ActivityLog()
        start_log.picker_username = current_user.username
        start_log.activity_type = 'picking_started'
        start_log.invoice_no = invoice_no
        start_log.details = f'Started picking order {invoice_no}'
        db.session.add(start_log)
        db.session.commit()
        
        # End any active idle periods when picker starts picking
        from utils.shift_tracking import end_idle_period
        end_idle_period(active_shift.id)
        
        # Pre-fetch all images for this invoice in background (performance optimization)
        from image_handler import prefetch_images_for_invoice
        items = InvoiceItem.query.filter_by(invoice_no=invoice_no).all()
        item_codes = [item.item_code for item in items]
        prefetch_images_for_invoice(item_codes)
    
    # Redirect to the picking page for the current item
    return redirect(url_for('pick_item', invoice_no=invoice_no))


@app.route('/api/picker/invoice/<invoice_no>/confirm-pick', methods=['POST'])
@login_required
def api_confirm_pick(invoice_no):
    """Fast JSON endpoint for confirming picks - allows async UI updates"""
    if current_user.role != 'picker':
        return jsonify({'ok': False, 'error': 'Access denied'}), 403

    invoice = Invoice.query.get_or_404(invoice_no)

    if invoice.assigned_to != current_user.username:
        return jsonify({'ok': False, 'error': 'Not assigned to this invoice'}), 403

    item_code = request.form.get('item_code')
    if not item_code:
        return jsonify({'ok': False, 'error': 'Missing item_code'}), 400

    current_item = InvoiceItem.query.filter_by(invoice_no=invoice_no, item_code=item_code).first()
    if not current_item:
        return jsonify({'ok': False, 'error': 'Item not found'}), 404

    if current_item.locked_by_batch_id is not None:
        return jsonify({'ok': False, 'error': 'Item locked by batch picking'}), 409

    try:
        picked_qty = int(request.form.get('picked_qty', current_item.expected_pick_pieces or current_item.qty or 0))
    except ValueError:
        return jsonify({'ok': False, 'error': 'Invalid picked_qty'}), 400

    expected_qty = current_item.expected_pick_pieces if current_item.expected_pick_pieces else current_item.qty
    if expected_qty is not None and picked_qty > expected_qty:
        return jsonify({'ok': False, 'error': 'Picked qty cannot exceed expected'}), 400

    # Complete time tracking for this item
    tracking_id = request.form.get('tracking_id')
    if tracking_id:
        try:
            from item_tracking import complete_item_tracking
            complete_item_tracking(
                tracking_id=int(tracking_id),
                picked_qty=picked_qty,
                picked_correctly=(expected_qty is not None and picked_qty == expected_qty),
                was_skipped=False
            )
        except Exception as e:
            current_app.logger.warning(f"Failed to complete item tracking: {e}")

    # Mark item as picked
    current_item.is_picked = True
    current_item.picked_qty = picked_qty

    if expected_qty is not None and picked_qty == expected_qty:
        current_item.pick_status = 'picked'
    else:
        current_item.pick_status = 'exception'

    # Sync batch record if exists
    from models import BatchPickedItem
    batch_record = BatchPickedItem.query.filter_by(invoice_no=invoice_no, item_code=item_code).first()
    if batch_record:
        batch_record.picked_qty = picked_qty
        db.session.add(batch_record)

    # Create exception record if mismatch
    if expected_qty is not None and picked_qty != expected_qty:
        exception = PickingException()
        exception.invoice_no = invoice_no
        exception.item_code = item_code
        exception.expected_qty = expected_qty
        exception.picked_qty = picked_qty
        exception.picker_username = current_user.username
        exception.reason = request.form.get('reason')
        db.session.add(exception)

    db.session.commit()

    # Update order status
    from batch_aware_order_status import update_order_status_batch_aware
    update_order_status_batch_aware(invoice_no)

    # Check if any items remain to pick (single EXISTS query)
    remaining = db.session.query(InvoiceItem.item_code).filter(
        InvoiceItem.invoice_no == invoice_no,
        InvoiceItem.is_picked.is_(False),
        InvoiceItem.locked_by_batch_id.is_(None)
    ).first()

    if remaining:
        next_url = url_for('pick_item', invoice_no=invoice_no)
    else:
        # Mark picking complete - move to awaiting_packing
        from timezone_utils import get_local_time
        invoice.picking_complete_time = utc_now_for_db()
        invoice.status = 'awaiting_packing'
        invoice.current_item_index = invoice.total_lines
        db.session.commit()
        next_url = url_for('ready_for_packing', invoice_no=invoice_no)

    return jsonify({'ok': True, 'next_url': next_url})


@app.route('/picker/invoice/<invoice_no>/item', methods=['GET', 'POST'])
@login_required
def pick_item(invoice_no):
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    # Check if picker has an active shift
    active_shift = get_active_shift(current_user.username)
    if not active_shift:
        flash('You must check in for a shift before picking.', 'warning')
        return redirect(url_for('shift_check_in'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Verify this picker is assigned to this invoice
    if invoice.assigned_to != current_user.username:
        flash('You are not assigned to this invoice.', 'danger')
        return redirect(url_for('picker_dashboard'))
    
    # Check for time tracking alerts before proceeding
    from time_alerts import check_order_time_alerts
    alert_info = check_order_time_alerts(invoice_no, current_user.username)
    
    # OPTIMIZED: Single query to get all items with lock status (no sorting - will apply sort_items_by_config)
    from sqlalchemy import text
    query = text("""
        SELECT ii.*, 
               CASE 
                   WHEN ii.locked_by_batch_id IS NOT NULL THEN 'batch_locked'
                   WHEN ii.is_picked = true THEN 'picked'
                   WHEN ii.pick_status = 'skipped_pending' THEN 'skipped_pending'
                   WHEN ii.pick_status = 'reset' THEN 'reset'
                   ELSE 'available'
               END as item_status,
               bps.name as lock_batch_name
        FROM invoice_items ii
        LEFT JOIN batch_picking_sessions bps ON ii.locked_by_batch_id = bps.id 
            AND bps.status IN ('Active', 'Paused')
        WHERE ii.invoice_no = :invoice_no
    """)
    
    # Run the optimized raw SQL query with mappings for named access
    raw_rows = db.session.execute(query, {'invoice_no': invoice_no}).mappings().all()
    
    if not raw_rows:
        flash('No items found for this invoice.', 'warning')
        return redirect(url_for('picker_dashboard'))
    
    # BULK FETCH: load all invoice items once (eliminates N+1 queries)
    invoice_items = InvoiceItem.query.filter_by(invoice_no=invoice_no).all()
    items_by_code = {i.item_code: i for i in invoice_items}
    
    all_items = []
    items_to_pick = []
    locked_by_batches = []
    
    for r in raw_rows:
        item_code = r.get('item_code')
        if not item_code:
            continue
        
        item = items_by_code.get(item_code)
        if not item:
            continue
        
        all_items.append(item)
        item_status = r.get('item_status')
        
        # Handle batch locked items separately
        if item_status == 'batch_locked':
            locked_by_batches.append(item)
            continue
        
        # Add pickable items
        if item_status in ('available', 'reset', 'skipped_pending'):
            items_to_pick.append(item)
    
    # Log locked items warning if any
    if locked_by_batches:
        current_app.logger.info(f"Blocked {len(locked_by_batches)} batch-locked items from regular picking in {invoice_no}")
    
    # If all remaining items are locked by batches, redirect to dashboard
    if len(locked_by_batches) > 0 and not items_to_pick:
        flash(f'All remaining items in this order are assigned to batch picking sessions and cannot be picked individually.', 'warning')
        return redirect(url_for('picker_dashboard'))
    
    # If all items are picked, check for skipped items that need resolution
    if not items_to_pick:
        # Mark any items not explicitly picked as skipped
        for item in all_items:
            if not item.is_picked and not item.pick_status:
                item.pick_status = 'skipped'
        
        # For completed invoices, set current_item_index to total_lines
        # This ensures progress indicators show 100% completion
        invoice.status = 'awaiting_packing'
        invoice.current_item_index = invoice.total_lines
        db.session.commit()
        flash('All items have been picked! Please proceed to the packing zone.', 'success')
        return redirect(url_for('ready_for_packing', invoice_no=invoice_no))
    
    # Check if there are only skipped_pending items left
    only_skipped_pending = all(item.pick_status == 'skipped_pending' for item in items_to_pick)
    if only_skipped_pending:
        flash('You have skipped items that need to be resolved before completing this order.', 'warning')
    
    # Apply configurable sorting from admin settings (sort_items_by_config handles skipped items last)
    sorted_items_to_pick = sort_items_by_config(items_to_pick)
    
    # Sorting complete - items are now in proper sequence based on admin sorting configuration
    
    # For a POST request (item being picked)
    if request.method == 'POST':
        # Store the item code of the current item being picked to find it again after sorting
        try:
            current_item_code = request.form.get('item_code')
            if not current_item_code:
                # If no item code was provided, get it from the first unpicked item
                if sorted_items_to_pick:
                    current_item_code = sorted_items_to_pick[0].item_code
                else:
                    flash('No items left to pick', 'warning')
                    return redirect(url_for('picker_dashboard'))
                    
            # Find the item by its code
            current_item = next((item for item in sorted_items_to_pick if item.item_code == current_item_code), None)
            
            if not current_item:
                # Check if the item exists in the original list but was filtered out
                original_item = next((item for item in items_to_pick if item.item_code == current_item_code), None)
                if original_item:
                    # Item exists but was filtered out - check if it's locked by batch
                    from batch_locking_utils import check_item_lock_status
                    lock_status = check_item_lock_status(original_item.invoice_no, original_item.item_code)
                    if lock_status['locked']:
                        flash(f'Item {current_item_code} is locked by {lock_status["message"]}. This item must be picked through batch picking.', 'danger')
                        return redirect(url_for('picker_dashboard'))
                
                # Log the error for debugging
                current_app.logger.error(f"Item {current_item_code} not found in sorted list. Available items: {[item.item_code for item in sorted_items_to_pick]}")
                flash('Item not found or already picked', 'warning')
                return redirect(url_for('pick_item', invoice_no=invoice_no))
            
            # OPTIMIZED: Check if item is locked by batch (already filtered in main query)
            if current_item.locked_by_batch_id is not None:
                flash(f'Cannot pick item {current_item.item_code}: Item is locked by batch picking. This item must be picked through batch picking.', 'danger')
                return redirect(url_for('picker_dashboard'))
            
            # Check if the item is being skipped
            if request.form.get('skip') == 'true':
                # Process the skip action
                skip_reason = request.form.get('skip_reason', '')
                if skip_reason == 'Other':
                    other_reason = request.form.get('other_skip_reason', '')
                    if other_reason:
                        skip_reason = other_reason
                
                # Mark the item as skipped_pending
                current_item.pick_status = 'skipped_pending'
                current_item.skip_reason = skip_reason
                current_item.skip_timestamp = utc_now_for_db()
                
                # Increment skip count - handle attribute error gracefully
                try:
                    if current_item.skip_count is None:
                        current_item.skip_count = 1
                    else:
                        current_item.skip_count += 1
                except (AttributeError, TypeError):
                    # If skip_count doesn't exist or has an unexpected type
                    current_item.skip_count = 1
                
                # Log the skip activity
                activity = ActivityLog()
                activity.picker_username = current_user.username
                activity.activity_type = 'item_skip'
                activity.invoice_no = invoice_no
                activity.item_code = current_item.item_code
                activity.details = f"Skipped item with reason: {skip_reason}"
                db.session.add(activity)
                
                # Save to the database
                db.session.commit()
                
                # Update order status with batch-aware logic
                from batch_aware_order_status import update_order_status_batch_aware
                status_summary = update_order_status_batch_aware(invoice_no)
                
                # Move this item to the end of the picking queue
                # We'll achieve this in GET request handling by prioritizing non-skipped items
                
                # Removed confirmation message as requested
                return redirect(url_for('pick_item', invoice_no=invoice_no))
                
            # Process the pick
            picked_qty = int(request.form.get('picked_qty', current_item.expected_pick_pieces or current_item.qty))
            confirm = request.form.get('confirm') == 'true'
            
            # Validate picked quantity against expected pieces
            expected_qty = current_item.expected_pick_pieces if current_item.expected_pick_pieces else current_item.qty
            if picked_qty > expected_qty:
                flash('Error: Picked quantity cannot exceed expected quantity', 'danger')
                return redirect(url_for('pick_item', invoice_no=invoice_no))
            
            if confirm:
                # Complete time tracking for this item
                tracking_id = request.form.get('tracking_id')
                if tracking_id:
                    try:
                        from item_tracking import complete_item_tracking
                        complete_item_tracking(
                            tracking_id=int(tracking_id),
                            picked_qty=picked_qty,
                            picked_correctly=(picked_qty == expected_qty),
                            was_skipped=False
                        )
                    except Exception as e:
                        current_app.logger.warning(f"Failed to complete item tracking: {e}")
                
                # Mark the item as picked
                current_item.is_picked = True
                current_item.picked_qty = picked_qty
                
                # Update the pick status based on expected quantity
                expected_qty = current_item.expected_pick_pieces if current_item.expected_pick_pieces else current_item.qty
                if picked_qty == expected_qty:
                    current_item.pick_status = 'picked'
                else:
                    current_item.pick_status = 'exception'
                
                # CRITICAL FIX: Update batch records if this item is part of a batch
                # This prevents data inconsistency between individual and batch picking
                from models import BatchPickedItem
                batch_record = BatchPickedItem.query.filter_by(
                    invoice_no=current_item.invoice_no,
                    item_code=current_item.item_code
                ).first()
                
                if batch_record:
                    batch_record.picked_qty = picked_qty
                    current_app.logger.info(f"ðŸ”„ SYNC FIX: Updated batch record for {current_item.item_code} to {picked_qty} (individual pick)")
                    db.session.add(batch_record)
                
                # Log an exception if quantities don't match expected
                expected_qty = current_item.expected_pick_pieces if current_item.expected_pick_pieces else current_item.qty
                if picked_qty != expected_qty:
                    exception = PickingException()
                    exception.invoice_no = invoice_no
                    exception.item_code = current_item.item_code
                    exception.expected_qty = expected_qty
                    exception.picked_qty = picked_qty
                    exception.picker_username = current_user.username
                    exception.reason = request.form.get('reason')
                    db.session.add(exception)
                
                # Save to the database
                db.session.commit()
                
                # Update order status with batch-aware logic
                from batch_aware_order_status import update_order_status_batch_aware
                status_summary = update_order_status_batch_aware(invoice_no)
                
                # Refresh the list of items to pick
                items_to_pick = [item for item in all_items 
                                if not item.is_picked or item.pick_status == 'reset']
                sorted_items_to_pick = sort_items_by_config(items_to_pick)
                
                # If there are more items to pick, continue
                if sorted_items_to_pick:
                    return redirect(url_for('pick_item', invoice_no=invoice_no))
                else:
                    # Record picking completion time
                    from timezone_utils import get_local_time
                    invoice.picking_complete_time = utc_now_for_db()
                    invoice.current_item_index = invoice.total_lines
                    db.session.commit()
                    flash('All items have been picked! Please proceed to the packing zone.', 'success')
                    return redirect(url_for('ready_for_packing', invoice_no=invoice_no))
                    
        except ValueError:
            flash('Invalid quantity value', 'danger')
            return redirect(url_for('pick_item', invoice_no=invoice_no))
    
    # For a GET request (showing the next item to pick)
    # Always pick the first unpicked item from the sorted list
    if not sorted_items_to_pick:
        flash('No items left to pick for this invoice.', 'warning')
        return redirect(url_for('picker_dashboard'))
        
    # Get the first item in the sorted unpicked items list
    current_item = sorted_items_to_pick[0]
    
    # Check if this is a skipped item being resolved
    is_skipped_resolution = current_item.pick_status == 'skipped_pending'
    
    # Parse the location into components for display
    # For format "10-06-A 01": corridor-aisle-level bin
    location_parts = {'aisle': '', 'shelf': '', 'level': '', 'bin': ''}
    if current_item.location:
        # Standardize for parsing: remove dashes and spaces
        clean_loc = current_item.location.strip().upper().replace("-", "").replace(" ", "")
        
        # Expected pattern: 2 digits (corridor) + 2 digits (aisle) + 1 char (level) + 2 digits (bin)
        if len(clean_loc) == 7:
            location_parts['aisle'] = clean_loc[0:2]  # corridor (10)
            location_parts['shelf'] = clean_loc[2:4]  # aisle/shelf (06)
            location_parts['level'] = clean_loc[4]    # level (A)
            location_parts['bin'] = clean_loc[5:7]    # bin (01)
        else:
            # Fallback for other formats
            parts = current_item.location.strip().split('-')
            if len(parts) >= 1:
                location_parts['aisle'] = parts[0]
            if len(parts) >= 2:
                location_parts['shelf'] = parts[1]
            if len(parts) >= 3:
                level_bin = parts[2]
                import re
                match = re.match(r'([A-Za-z]*)(\d*)', level_bin)
                if match:
                    level_part, bin_part = match.groups()
                    location_parts['level'] = level_part
                    location_parts['bin'] = bin_part
    
    # Check if there's a next item after the CURRENT item and get its location
    # Format the next location for display preview
    next_item_location = None
    if len(sorted_items_to_pick) > 1:
        next_item = sorted_items_to_pick[1]
        if next_item and next_item.location:
            raw_next = next_item.location.strip().upper().replace("-", "").replace(" ", "")
            if len(raw_next) == 7:
                next_item_location = f"{raw_next[0:2]}-{raw_next[2:4]}-{raw_next[4]} {raw_next[5:7]}"
            else:
                next_item_location = next_item.location
    
    # Get product image for confirmation screen
    product_image = get_product_image(current_item.item_code)
    
    # Get configuration settings
    confirm_picking = Setting.get(db.session, 'confirm_picking_step', 'true')
    show_image = Setting.get(db.session, 'show_image_on_picking_screen', 'true')
    require_skip_reason = Setting.get(db.session, 'require_skip_reason', 'true')
    
    # Get skip reasons list
    default_skip_reasons = "Need assistance\nLocation not accessible\nNeed equipment\nNeed to check with supervisor"
    skip_reasons = Setting.get(db.session, 'skip_reasons', default_skip_reasons)
    skip_reasons_list = [reason.strip() for reason in skip_reasons.splitlines() if reason.strip()]
    
    # Calculate picked items count for progress display
    picked_items_count = len([item for item in all_items if item.is_picked])
    total_items_count = len(all_items)
    
    # Start per-product time tracking for AI analysis
    tracking_id = None
    try:
        from item_tracking import start_item_tracking
        
        # Get previous location for distance calculation
        previous_location = None
        if picked_items_count > 0:
            last_picked = [item for item in all_items if item.is_picked]
            if last_picked:
                previous_location = last_picked[-1].location
        
        tracking = start_item_tracking(
            invoice_no=invoice_no,
            item_code=current_item.item_code,
            picker_username=current_user.username,
            previous_location=previous_location
        )
        
        if tracking:
            tracking_id = tracking.id
    except Exception as e:
        print(f"Error starting item tracking: {e}")
    
    # Get the multi-quantity warning setting
    show_multi_qty_warning = Setting.get(db.session, 'show_multi_qty_warning', 'true')
    
    # Get exception reasons for the issue modal
    default_exception_reasons = "Item not found\nInsufficient quantity\nDamaged product\nWrong location\nOther"
    exception_reasons_text = Setting.get(db.session, 'exception_reasons', default_exception_reasons)
    exception_reasons_list = [reason.strip() for reason in exception_reasons_text.split('\n') if reason.strip()]
    
    return render_template('picking.html', 
                          invoice=invoice, 
                          item=current_item, 
                          location_parts=location_parts, 
                          current_index=invoice.current_item_index + 1, 
                          remaining_items=len(sorted_items_to_pick),
                          picked_items=picked_items_count,
                          total_items=total_items_count,
                          product_image=product_image,
                          confirm_picking=confirm_picking,
                          show_image=show_image,
                          next_item_location=next_item_location,
                          require_skip_reason=require_skip_reason,
                          skip_reasons_list=skip_reasons_list,
                          exception_reasons_list=exception_reasons_list,
                          is_reset_item=current_item.pick_status == 'reset',
                          is_skipped_resolution=is_skipped_resolution,
                          skip_reason=current_item.skip_reason if is_skipped_resolution else None,
                          tracking_id=tracking_id,
                          show_multi_qty_warning=show_multi_qty_warning)

@app.route('/picker/invoice/<invoice_no>/completed')
@login_required
def picking_completed(invoice_no):
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Verify this picker is assigned to this invoice
    if invoice.assigned_to != current_user.username:
        flash('You are not assigned to this invoice.', 'danger')
        return redirect(url_for('picker_dashboard'))
    
    # Check if there were any exceptions during picking
    exceptions = PickingException.query.filter_by(invoice_no=invoice_no).all()
    
    return render_template('picking_completed.html', invoice=invoice, exceptions=exceptions)

@app.route('/picking-timeline/<string:invoice_no>')
@login_required
def picking_timeline_report(invoice_no):
    """Compact picking log report showing who picked what and when, separated by batch"""
    if current_user.role not in ['admin', 'manager', 'picker']:
        flash('Access denied. Insufficient privileges.', 'danger')
        return redirect(url_for('index'))
    
    # Get invoice
    invoice = Invoice.query.filter_by(invoice_no=invoice_no).first()
    if not invoice:
        flash('Invoice not found.', 'danger')
        return redirect(url_for('index'))
    
    # Get all item tracking records for this invoice
    from models import ItemTimeTracking
    item_tracking = ItemTimeTracking.query.filter_by(
        invoice_no=invoice_no
    ).filter(
        ItemTimeTracking.item_completed.isnot(None)
    ).order_by(ItemTimeTracking.item_completed.asc()).all()
    
    # Get batch picked items
    from models import BatchPickedItem, BatchPickingSession
    batch_picked_records = BatchPickedItem.query.filter_by(invoice_no=invoice_no).all()
    
    # Convert to the format expected by the code
    batch_picked_items = []
    batch_item_codes = set()
    
    for record in batch_picked_records:
        # Get the original invoice item for details
        item = InvoiceItem.query.filter_by(
            invoice_no=invoice_no, 
            item_code=record.item_code
        ).first()
        
        if item:
            batch_picked_items.append({
                'item_code': record.item_code,
                'item_name': item.item_name,
                'location': item.location,
                'unit_type': item.unit_type,
                'pack': item.pack,
                'batch_id': record.batch_session_id,
                'qty': record.picked_qty,
                'requested_qty': item.qty
            })
            batch_item_codes.add(record.item_code)
    
    # Separate manual vs batch picks
    manual_picks = []
    batch_picks = []
    
    for tracking in item_tracking:
        pick_data = {
            'item_code': tracking.item_code,
            'item_name': tracking.item_name,
            'location': tracking.location,
            'quantity_picked': tracking.quantity_picked,
            'picker': tracking.picker_username,
            'completed_time': tracking.item_completed,
            'total_time_minutes': round(tracking.total_item_time / 60, 2) if tracking.total_item_time else 0,
            'was_skipped': tracking.was_skipped,
            'skip_reason': tracking.skip_reason
        }
        
        if tracking.item_code in batch_item_codes:
            # Find batch info
            batch_info = None
            for batch_item in batch_picked_items:
                if batch_item['item_code'] == tracking.item_code:
                    batch_info = batch_item
                    break
            pick_data['batch_id'] = batch_info['batch_id'] if batch_info else 'Unknown'
            batch_picks.append(pick_data)
        else:
            manual_picks.append(pick_data)
    
    # Group batch picks by batch ID
    batch_picks_grouped = {}
    for pick in batch_picks:
        batch_id = pick['batch_id']
        if batch_id not in batch_picks_grouped:
            batch_picks_grouped[batch_id] = []
        batch_picks_grouped[batch_id].append(pick)
    
    return render_template('picking_timeline_report.html',
                         invoice=invoice,
                         manual_picks=manual_picks,
                         batch_picks_grouped=batch_picks_grouped,
                         total_items=len(manual_picks) + len(batch_picks))

@app.route('/admin/invoice/<invoice_no>/print')
@login_required
def print_invoice(invoice_no):
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Check access permissions
    if current_user.role not in ['admin', 'warehouse_manager'] and current_user.username != invoice.assigned_to:
        flash('Access denied. Only admin or the assigned picker can print this invoice.', 'danger')
        return redirect(url_for('index'))
    
    # Check if this was called from the packing confirmation screen
    return_to_packing = request.args.get('from_packing') == 'true'
    
    # Get route information for this invoice
    from models import RouteStopInvoice, RouteStop, Shipment
    route_info = None
    route_stop_invoice = RouteStopInvoice.query.filter_by(invoice_no=invoice_no).first()
    if route_stop_invoice:
        route_stop = RouteStop.query.get(route_stop_invoice.route_stop_id)
        if route_stop:
            shipment = Shipment.query.get(route_stop.shipment_id)
            if shipment:
                route_info = {
                    'route_id': shipment.id,
                    'route_name': shipment.route_name or f"Route #{shipment.id}",
                    'delivery_date': shipment.delivery_date,
                    'driver_name': shipment.driver_name,
                    'stop_seq': route_stop.seq_no,
                    'stop_name': route_stop.stop_name,
                    'stop_addr': route_stop.stop_addr,
                    'stop_city': route_stop.stop_city,
                    'stop_notes': route_stop.notes,
                    'invoice_notes': route_stop_invoice.notes,
                    'status': shipment.status
                }
    
    # Admin can print invoices in any status
    
    # Get all items for this invoice, sorted using the same logic as picker interface
    all_items = InvoiceItem.query.filter_by(invoice_no=invoice_no).all()
    all_items = sort_items_by_config(all_items)
    
    # Get any exceptions for this invoice
    exceptions = PickingException.query.filter_by(invoice_no=invoice_no).all()
    
    # Get batch-picked items for this invoice
    from models import BatchPickedItem, BatchPickingSession
    batch_items = []
    batch_info = {}
    batch_item_codes = set()  # To track which items were batch-picked
    
    # Query for batch-picked items
    batch_picked_records = BatchPickedItem.query.filter_by(invoice_no=invoice_no).all()
    
    if batch_picked_records:
        for record in batch_picked_records:
            # Get the original invoice item for details
            item = InvoiceItem.query.filter_by(
                invoice_no=invoice_no, 
                item_code=record.item_code
            ).first()
            
            if item:
                # Add item code to the tracking set
                batch_item_codes.add(item.item_code)
                
                # Get batch session details
                if record.batch_session_id not in batch_info:
                    batch = BatchPickingSession.query.get(record.batch_session_id)
                    batch_info[str(record.batch_session_id)] = {
                        'id': record.batch_session_id,
                        'name': batch.name if batch else f"Batch #{record.batch_session_id}",
                        'batch_number': batch.batch_number if batch and batch.batch_number else f"BATCH-{record.batch_session_id}"
                    }
                
                # Create batch item entry with all necessary fields
                batch_items.append({
                    'item_code': item.item_code,
                    'item_name': item.item_name,
                    'location': item.location,
                    'unit_type': item.unit_type,
                    'pack': item.pack,
                    'batch_id': record.batch_session_id,
                    'batch_name': batch_info[str(record.batch_session_id)]['name'],
                    'qty': record.picked_qty,
                    'requested_qty': item.qty
                })
    
    # Mark items as batch-picked or not and identify all batch-assigned items
    batch_assigned_codes = set()  # Track all items assigned to batches (picked or not)
    for item in all_items:
        if item.item_code in batch_item_codes:
            item.batch_id = True  # Mark as batch-picked
        # Also track items assigned to batches but not yet picked
        if item.locked_by_batch_id:
            batch_assigned_codes.add(item.item_code)
    
    # Process manually picked items (those not assigned to any batch)
    manually_picked = [item for item in all_items if item.item_code not in batch_assigned_codes]
    
    # Group manually picked items by zone for better organization
    # Items are already sorted by sort_items_by_config, so we preserve that order
    from sorting_utils import get_item_sort_key
    manually_picked_by_zone = {}
    for item in manually_picked:
        zone = item.zone or 'Unknown Zone'
        if zone not in manually_picked_by_zone:
            manually_picked_by_zone[zone] = []
        manually_picked_by_zone[zone].append(item)
    
    # Re-sort items within each zone using the proper sort key (preserves zone/corridor/shelf/bin order)
    for zone in manually_picked_by_zone:
        manually_picked_by_zone[zone].sort(key=lambda x: get_item_sort_key(x))
    
    # Add unpicked batch-assigned items to batch_items
    for item in all_items:
        if item.locked_by_batch_id and item.item_code not in batch_item_codes:
            # This item is assigned to a batch but hasn't been picked via batch yet
            batch_items.append({
                'item_code': item.item_code,
                'item_name': item.item_name,
                'location': item.location,
                'unit_type': item.unit_type,
                'pack': item.pack,
                'batch_id': item.locked_by_batch_id,
                'batch_name': f"Batch {item.locked_by_batch_id}",
                'qty': 0,  # Not picked yet
                'requested_qty': item.qty,
                'status': 'not_picked'
            })
    
    # Group batch items by zone as well
    batch_items_by_zone = {}
    for item in batch_items:
        # Get the original item to find its zone
        original_item = next((i for i in all_items if i.item_code == item['item_code']), None)
        zone = original_item.zone if original_item and original_item.zone else 'Unknown Zone'
        if zone not in batch_items_by_zone:
            batch_items_by_zone[zone] = {}
        
        batch_id = item['batch_id']
        if batch_id not in batch_items_by_zone[zone]:
            batch_items_by_zone[zone][batch_id] = []
        batch_items_by_zone[zone][batch_id].append(item)
    
    # Count statistics
    total_item_count = len(all_items)
    manual_count = len(manually_picked)
    batch_count = len(batch_items)
    
    # Choose the appropriate template based on the order status and user role
    if invoice.status in ['Ready for Packing', 'ready_for_dispatch'] or (current_user.role == 'picker' and invoice.status in ['In Progress', 'picking']):
        # Use the picking report template for packing preparation
        return render_template('print_picking_report.html', 
                             invoice=invoice, 
                             items=all_items,         # All items with batch_id flag
                             manually_picked=manually_picked,  # Only manually picked items
                             manually_picked_by_zone=manually_picked_by_zone,  # Grouped by zone
                             exceptions=exceptions,
                             batch_items=batch_items,
                             batch_items_by_zone=batch_items_by_zone,  # Grouped by zone
                             batch_info=batch_info,
                             total_count=total_item_count,
                             manual_count=manual_count,
                             batch_count=batch_count,
                             current_user=current_user,
                             return_to_packing=return_to_packing,
                             route_info=route_info,
                             now=datetime.now())
    else:
        # Use the shipping label template for completed orders
        return render_template('print_invoice.html', 
                             invoice=invoice, 
                             items=all_items,
                             manually_picked=manually_picked,
                             exceptions=exceptions,
                             batch_items=batch_items,
                             batch_info=batch_info,
                             return_to_packing=return_to_packing,
                             route_info=route_info,
                             total_count=total_item_count,
                             manual_count=manual_count,
                             batch_count=batch_count,
                             now=datetime.now())


# Batch Picking - Create Session
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Manage Sessions
# Batch picking route handler removed - will be rebuilt

# Batch Picking - View Session Details
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Assign to Picker
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Delete Session
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Start Session (for pickers)
# Batch picking route handler removed - will be rebuilt

# Batch picking route handler removed - will be rebuilt
# Batch picking function removed - will be rebuilt
    
# Batch picking function removed - will be rebuilt

# Batch Picking - Pick Items
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Completed
# Batch picking route handler removed - will be rebuilt

# Batch Picking - Print Report
# Batch picking route handler removed - will be rebuilt

# Ready for Packing Screen
@app.route('/picker/invoice/<invoice_no>/ready-for-packing')
@login_required
def ready_for_packing(invoice_no):
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Verify this picker is assigned to this invoice
    if invoice.assigned_to != current_user.username:
        flash('You are not assigned to this invoice.', 'danger')
        return redirect(url_for('picker_dashboard'))
    
    # Check for skipped items that need resolution
    skipped_items = InvoiceItem.query.filter_by(
        invoice_no=invoice_no, 
        pick_status='skipped_pending'
    ).all()
    
    if skipped_items:
        # There are skipped items that need resolution
        flash('You have skipped items that need to be resolved before packing. Please complete picking all items.', 'warning')
        return redirect(url_for('pick_item', invoice_no=invoice_no))
    
    # Get all exceptions for this invoice
    exceptions = PickingException.query.filter_by(invoice_no=invoice_no).all()
    
    return render_template('ready_for_packing.html', invoice=invoice, exceptions=exceptions, now=datetime.now())

# Mark Packing as Complete
@app.route('/picker/invoice/<invoice_no>/mark-as-packed', methods=['POST'])
@login_required
def mark_as_packed(invoice_no):
    if current_user.role != 'picker':
        flash('Access denied. Picker privileges required.', 'danger')
        return redirect(url_for('index'))
    
    invoice = Invoice.query.get_or_404(invoice_no)
    
    # Verify this picker is assigned to this invoice
    if invoice.assigned_to != current_user.username:
        flash('You are not assigned to this invoice.', 'danger')
        return redirect(url_for('picker_dashboard'))
        
    # Double check for skipped items that need resolution
    skipped_items = InvoiceItem.query.filter_by(
        invoice_no=invoice_no, 
        pick_status='skipped_pending'
    ).all()
    
    if skipped_items:
        # There are skipped items that need resolution
        flash('You have skipped items that need to be resolved before packing. Please complete picking all items.', 'warning')
        return redirect(url_for('pick_item', invoice_no=invoice_no))
    
    # Update the invoice status to ready_for_dispatch and record packing time
    from timezone_utils import get_local_time
    invoice.status = 'ready_for_dispatch'
    invoice.packing_complete_time = utc_now_for_db()
    
    # Log the actual completion time for accurate time tracking
    from models import ActivityLog
    completion_log = ActivityLog()
    completion_log.picker_username = current_user.username
    completion_log.activity_type = 'picking_completed'
    completion_log.invoice_no = invoice_no
    completion_log.details = f'Completed order {invoice_no}'
    db.session.add(completion_log)
    db.session.commit()
    
    flash('Order has been marked as packed and completed successfully.', 'success')
    return redirect(url_for('picking_completed', invoice_no=invoice_no))

# Error handlers
@app.errorhandler(404)
def page_not_found(e):
    return render_template('error.html', error_code=404, error_message='Page not found'), 404

@app.errorhandler(403)
def forbidden(e):
    return render_template('403.html'), 403

@app.errorhandler(500)
def server_error(e):
    return render_template('error.html', error_code=500, error_message='Server error'), 500
@app.route('/admin/update-routing-number', methods=['POST'])
@login_required
def update_routing_number():
    """Update the routing number for an invoice"""
    try:
        data = request.get_json()
        invoice_no = data.get('invoice_no')
        routing_number = data.get('routing_number')
        
        if not invoice_no:
            return jsonify({'success': False, 'error': 'Invoice number is required'})
        
        # Find the invoice
        invoice = Invoice.query.filter_by(invoice_no=invoice_no).first()
        if not invoice:
            return jsonify({'success': False, 'error': 'Invoice not found'})
        
        # Update the routing number (convert empty string to None)
        invoice.routing = routing_number if routing_number.strip() else None
        
        # Log the activity
        activity_log = ActivityLog()
        activity_log.invoice_no = invoice_no
        activity_log.activity_type = 'admin_correction'
        activity_log.details = f'Routing number updated to: {routing_number or "None"} by {current_user.username}'
        activity_log.picker_username = current_user.username
        activity_log.timestamp = utc_now_for_db()
        db.session.add(activity_log)
        
        # Commit the changes
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Routing number updated successfully'})
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error updating routing number: {str(e)}")
        return jsonify({'success': False, 'error': 'Failed to update routing number'})

@app.route('/admin/update-stop-sequence', methods=['POST'])
@login_required
def update_stop_sequence():
    """Update the stop sequence number for an invoice (supports decimal sequences like 1.1, 1.5)"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        from decimal import Decimal
        data = request.get_json()
        invoice_no = data.get('invoice_no')
        new_sequence = data.get('sequence')
        
        if not invoice_no:
            return jsonify({'success': False, 'error': 'Invoice number is required'})
        
        if new_sequence is None or new_sequence < 0.01:
            return jsonify({'success': False, 'error': 'Invalid sequence number'})
        
        # Convert to Decimal and normalize to 1 decimal place
        new_sequence = Decimal(str(new_sequence)).quantize(Decimal('0.1'))
        
        # Find the invoice
        invoice = Invoice.query.filter_by(invoice_no=invoice_no).first()
        if not invoice:
            return jsonify({'success': False, 'error': 'Invoice not found'})
        
        if not invoice.stop_id:
            return jsonify({'success': False, 'error': 'Invoice is not assigned to a stop'})
        
        # Update the stop sequence
        from models import RouteStop
        stop = RouteStop.query.filter_by(route_stop_id=invoice.stop_id).first()
        if not stop:
            return jsonify({'success': False, 'error': 'Stop not found'})
        
        old_sequence = stop.seq_no
        route_id = stop.shipment_id
        
        # Check if another stop in the same route already has this sequence
        conflicting_stop = RouteStop.query.filter_by(
            shipment_id=route_id,
            seq_no=new_sequence
        ).filter(RouteStop.route_stop_id != invoice.stop_id).first()
        
        if conflicting_stop:
            # TRUE SWAP: Move the conflicting stop to the OLD sequence of the current stop
            # This way, if stop A (seq 1) wants to be seq 3, and stop B is at seq 3,
            # stop B gets moved to seq 1 (the original position of stop A)
            
            # Use a temporary negative sequence to avoid unique constraint violation
            # Step 1: Move current stop to a temporary sequence
            temp_seq = Decimal('-9999')
            stop.seq_no = temp_seq
            db.session.flush()
            
            # Step 2: Move conflicting stop to the old sequence (now available)
            conflicting_stop.seq_no = old_sequence
            db.session.flush()
            
            # Step 3: Move current stop to the new sequence (now available)
            stop.seq_no = new_sequence
            
            # Log the automatic swap
            swap_log = ActivityLog()
            swap_log.invoice_no = invoice_no
            swap_log.activity_type = 'admin_correction'
            swap_log.details = f'Auto-swapped stop {conflicting_stop.route_stop_id} from seq {new_sequence} to {old_sequence} (true swap) by {current_user.username}'
            swap_log.picker_username = current_user.username
            swap_log.timestamp = utc_now_for_db()
            db.session.add(swap_log)
        else:
            # No conflict, just update the sequence
            stop.seq_no = new_sequence
        
        # Log the activity
        activity_log = ActivityLog()
        activity_log.invoice_no = invoice_no
        activity_log.activity_type = 'admin_correction'
        activity_log.details = f'Stop sequence updated from {old_sequence} to {new_sequence} by {current_user.username}'
        activity_log.picker_username = current_user.username
        activity_log.timestamp = utc_now_for_db()
        db.session.add(activity_log)
        
        # Commit the changes
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Stop sequence updated successfully'})
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error updating stop sequence: {str(e)}")
        return jsonify({'success': False, 'error': 'Failed to update stop sequence'})
    
@app.route('/admin/quick-view-breakdown', methods=['POST'])
@login_required
def quick_view_breakdown():
    if current_user.role not in ['admin', 'warehouse_manager']:
        return jsonify({'error': 'Access denied'}), 403
    
    data = request.get_json()
    invoice_nos = data.get('invoice_nos', [])
    
    if not invoice_nos:
        return jsonify({'error': 'No orders selected'}), 400
    
    # Get order details
    orders = Invoice.query.filter(Invoice.invoice_no.in_(invoice_nos)).all()
    
    # Get items for all selected orders
    items = InvoiceItem.query.filter(InvoiceItem.invoice_no.in_(invoice_nos)).all()
    
    # Calculate unit type breakdown
    unit_counts = {}
    total_items = 0
    case_items = []  # Collect all case items for detailed review
    
    for item in items:
        unit_type = item.unit_type or 'Unknown'
        quantity = item.qty or 0
        
        if unit_type not in unit_counts:
            unit_counts[unit_type] = 0
        unit_counts[unit_type] += quantity
        total_items += quantity
        
        # Collect case items for detailed review
        if unit_type.lower() in ['case', 'cases', 'cs', 'cse']:
            case_items.append({
                'invoice_no': item.invoice_no,
                'item_code': item.item_code,
                'item_name': item.item_name or 'Unknown Item',
                'quantity': quantity,
                'unit_type': unit_type,
                'location': item.location or 'Not specified'
            })
    
    # Calculate percentages and format breakdown
    unit_breakdown = []
    for unit_type, count in sorted(unit_counts.items()):
        percentage = round((count / total_items * 100), 1) if total_items > 0 else 0
        unit_breakdown.append({
            'unit_type': unit_type,
            'quantity': count,
            'percentage': percentage
        })
    
    # Calculate summary
    total_weight = sum(order.total_weight or 0 for order in orders)
    total_time = sum(order.total_exp_time or 0 for order in orders)
    
    # Format order details
    order_details = []
    for order in orders:
        order_details.append({
            'invoice_no': order.invoice_no,
            'customer_name': order.customer_name or 'Unknown',
            'total_items': order.total_items or 0,
            'total_weight': round(order.total_weight or 0, 1)
        })
    
    response_data = {
        'summary': {
            'total_orders': len(orders),
            'total_items': total_items,
            'total_weight': round(total_weight, 1),
            'total_time': round(total_time, 1),
            'total_cases': len(case_items)
        },
        'unit_breakdown': unit_breakdown,
        'case_items': case_items,
        'orders': order_details
    }
    
    return jsonify(response_data)

@app.route('/print_selected_orders', methods=['POST'])
@login_required
def print_selected_orders():
    """Print multiple selected orders from admin dashboard"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied. Admin privileges required.', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    # Get selected invoice numbers from form
    selected_invoices = request.form.getlist('selected_invoices')
    
    if not selected_invoices:
        flash('No orders selected for printing.', 'warning')
        return redirect(url_for('admin_dashboard'))
    
    # Fetch selected invoices with their items - using exact same structure as single invoice print
    invoices_data = []
    for invoice_no in selected_invoices:
        invoice = Invoice.query.filter_by(invoice_no=invoice_no).first()
        if not invoice:
            continue
            
        # Get all items for this invoice, sorted using the same logic as single print
        all_items = InvoiceItem.query.filter_by(invoice_no=invoice_no).all()
        all_items = sort_items_by_config(all_items)
        
        # Get any exceptions for this invoice
        exceptions = PickingException.query.filter_by(invoice_no=invoice_no).all()
        
        # Get batch-picked items for this invoice (same logic as single print)
        from models import BatchPickedItem, BatchPickingSession
        batch_items = []
        batch_info = {}
        batch_item_codes = set()
        
        # Query for batch-picked items
        batch_picked_records = BatchPickedItem.query.filter_by(invoice_no=invoice_no).all()
        
        if batch_picked_records:
            for record in batch_picked_records:
                # Get the original invoice item for details
                item = InvoiceItem.query.filter_by(
                    invoice_no=invoice_no, 
                    item_code=record.item_code
                ).first()
                
                if item:
                    # Add item code to the tracking set
                    batch_item_codes.add(item.item_code)
                    
                    # Get batch session details
                    if record.batch_session_id not in batch_info:
                        batch = BatchPickingSession.query.get(record.batch_session_id)
                        batch_info[str(record.batch_session_id)] = {
                            'id': record.batch_session_id,
                            'name': batch.name if batch else f"Batch #{record.batch_session_id}",
                            'batch_number': batch.batch_number if batch and batch.batch_number else f"BATCH-{record.batch_session_id}"
                        }
                    
                    # Create batch item entry with all necessary fields
                    batch_items.append({
                        'item_code': item.item_code,
                        'item_name': item.item_name,
                        'location': item.location,
                        'unit_type': item.unit_type,
                        'pack': item.pack,
                        'requested_qty': item.qty,
                        'qty': record.picked_qty,
                        'batch_id': record.batch_session_id
                    })
        
        # Mark items as batch-picked or not and identify all batch-assigned items
        batch_assigned_codes = set()  # Track all items assigned to batches (picked or not)
        for item in all_items:
            if item.item_code in batch_item_codes:
                item.batch_id = True  # Mark as batch-picked
            # Also track items assigned to batches but not yet picked
            if item.locked_by_batch_id:
                batch_assigned_codes.add(item.item_code)
        
        # Process manually picked items (those not assigned to any batch)
        manually_picked = [item for item in all_items if item.item_code not in batch_assigned_codes]
        
        # Add unpicked batch-assigned items to batch_items
        for item in all_items:
            if item.locked_by_batch_id and item.item_code not in batch_item_codes:
                # This item is assigned to a batch but hasn't been picked via batch yet
                batch_items.append({
                    'item_code': item.item_code,
                    'item_name': item.item_name,
                    'location': item.location,
                    'unit_type': item.unit_type,
                    'pack': item.pack,
                    'batch_id': item.locked_by_batch_id,
                    'batch_name': f"Batch {item.locked_by_batch_id}",
                    'qty': 0,  # Not picked yet
                    'requested_qty': item.qty,
                    'status': 'not_picked'
                })
        
        invoices_data.append({
            'invoice': invoice,
            'invoice_items': manually_picked,  # Only manually picked items (excludes batch items)
            'exceptions': exceptions,
            'batch_items': batch_items,
            'batch_info': batch_info,
            'total_items': len(all_items)
        })
    
    # Sort invoices by routing number descending for optimal picking sequence
    def get_routing_sort_key(invoice_data):
        routing = invoice_data['invoice'].routing
        if routing:
            try:
                return float(routing)
            except (ValueError, TypeError):
                return -1
        return -1
    
    invoices_data.sort(key=get_routing_sort_key, reverse=True)
    
    return render_template('print_selected_orders.html', 
                         invoices_data=invoices_data,
                         now=datetime.now())


@app.route('/view-stock-position')
@login_required
def view_stock_position():
    """Display extracted stock position data"""
    import pandas as pd
    from pathlib import Path
    
    csv_path = Path('attached_assets/stock_position_extracted.csv')
    
    if not csv_path.exists():
        flash('Stock position data not found. Please extract the data first.', 'warning')
        return redirect(url_for('dashboard'))
    
    df = pd.read_csv(csv_path)
    
    # Convert to list of dicts for template
    stock_data = df.to_dict('records')
    
    # Get filter options
    unique_items = sorted(df['Item Code'].unique().tolist())
    unique_stores = sorted(df['Store Name'].unique().tolist())
    
    # Summary stats
    stats = {
        'total_records': len(df),
        'unique_items': df['Item Code'].nunique(),
        'unique_stores': df['Store Name'].nunique(),
        'total_stock': df['Stock'].sum()
    }
    
    return render_template('view_stock_position.html',
                         stock_data=stock_data,
                         unique_items=unique_items,
                         unique_stores=unique_stores,
                         stats=stats)


@app.route('/stock-dashboard')
@login_required
def stock_dashboard():
    """Display stock position dashboard from database"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        flash('Access denied', 'danger')
        return redirect(url_for('picker_dashboard' if current_user.role == 'picker' else 'admin_dashboard'))
    
    # Get all stock positions from database
    stock_data = db.session.query(StockPosition).all()
    
    # Convert to dicts for template
    stock_list = []
    for stock in stock_data:
        stock_list.append({
            'Item Code': stock.item_code,
            'Item Description': stock.item_description or '',
            'Store Code': stock.store_code,
            'Store Name': stock.store_name,
            'Exp Date': stock.expiry_date or '',
            'Stock': float(stock.stock_quantity)
        })
    
    # Group by item code
    from datetime import datetime
    grouped_items = {}
    for row in stock_list:
        item_code = row['Item Code']
        if item_code not in grouped_items:
            grouped_items[item_code] = {
                'Item Code': item_code,
                'Item Description': row['Item Description'],
                'records': [],
                'earliest_date': None,
                'earliest_date_stock': 0,
                'total_stock': 0
            }
        grouped_items[item_code]['records'].append(row)
        grouped_items[item_code]['total_stock'] += row['Stock']
        
        # Track earliest expiration date and its stock
        try:
            if row['Exp Date']:
                exp_date = datetime.strptime(str(row['Exp Date']), '%Y-%m-%d').date()
                if grouped_items[item_code]['earliest_date'] is None or exp_date < grouped_items[item_code]['earliest_date']:
                    grouped_items[item_code]['earliest_date'] = exp_date
                    grouped_items[item_code]['earliest_date_stock'] = row['Stock']
                elif exp_date == grouped_items[item_code]['earliest_date']:
                    grouped_items[item_code]['earliest_date_stock'] += row['Stock']
        except:
            pass
    
    # Sort grouped items by earliest expiration date
    sorted_items = sorted(grouped_items.values(), key=lambda x: (x['earliest_date'] is None, x['earliest_date']))
    
    # Add record count and days to expiration for each item
    from datetime import date, timedelta
    today = date.today()
    
    for item in sorted_items:
        item['record_count'] = len(item['records'])
        
        # Calculate days to earliest expiration
        if item['earliest_date']:
            days_to_expire = (item['earliest_date'] - today).days
            item['days_to_expire'] = days_to_expire
            
            # Determine color based on days to expiration
            if days_to_expire <= 15:
                item['expiry_color'] = '#950606'  # Deep Red
                item['expiry_label'] = 'Critical'
            elif days_to_expire <= 30:
                item['expiry_color'] = '#FA5053'  # Light Red
                item['expiry_label'] = 'High'
            elif days_to_expire <= 60:
                item['expiry_color'] = '#FF7518'  # Orange
                item['expiry_label'] = 'Medium'
            elif days_to_expire <= 90:
                item['expiry_color'] = '#FFEF00'  # Yellow
                item['expiry_label'] = 'Low'
            else:
                item['expiry_color'] = '#2E6F40'  # Green
                item['expiry_label'] = 'Good'
        else:
            item['days_to_expire'] = None
            item['expiry_color'] = '#6c757d'
            item['expiry_label'] = 'No Date'
        
        # Calculate color for each record
        for record in item['records']:
            try:
                if record['Exp Date']:
                    record_exp_date = datetime.strptime(str(record['Exp Date']), '%Y-%m-%d').date()
                    record_days = (record_exp_date - today).days
                    
                    if record_days <= 15:
                        record['color'] = '#950606'
                    elif record_days <= 30:
                        record['color'] = '#FA5053'
                    elif record_days <= 60:
                        record['color'] = '#FF7518'
                    elif record_days <= 90:
                        record['color'] = '#FFEF00'
                    else:
                        record['color'] = '#2E6F40'
                else:
                    record['color'] = '#6c757d'
            except:
                record['color'] = '#6c757d'
    
    # Get filter options
    unique_items = sorted(list(set([s['Item Code'] for s in stock_list])))
    unique_stores = sorted(list(set([s['Store Name'] for s in stock_list])))
    
    # Summary stats
    stats = {
        'total_records': len(stock_list),
        'unique_items': len(unique_items),
        'unique_stores': len(unique_stores),
        'total_stock': sum(s['Stock'] for s in stock_list),
        'last_updated': max([s.imported_at for s in stock_data]).strftime('%Y-%m-%d %H:%M:%S') if stock_data else 'Never',
        'last_updated_obj': max([s.imported_at for s in stock_data]) if stock_data else None
    }
    
    return render_template('stock_dashboard.html',
                         grouped_items=sorted_items,
                         unique_items=unique_items,
                         unique_stores=unique_stores,
                         stats=stats)


@app.route('/api/refresh-stock-position', methods=['POST'])
@login_required
def refresh_stock_position():
    """Download and import stock position data from Dropbox"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        import requests
        import openpyxl
        from io import BytesIO
        from sqlalchemy import text
        
        logging.info("Starting stock position refresh...")
        
        # Get Dropbox connection
        hostname = os.environ.get('REPLIT_CONNECTORS_HOSTNAME')
        x_replit_token = None
        
        if os.environ.get('REPL_IDENTITY'):
            x_replit_token = 'repl ' + (os.environ.get('REPL_IDENTITY') or '')
        elif os.environ.get('WEB_REPL_RENEWAL'):
            x_replit_token = 'depl ' + (os.environ.get('WEB_REPL_RENEWAL') or '')
        
        logging.info(f"Hostname: {hostname}, Token exists: {bool(x_replit_token)}")
        
        if not hostname or not x_replit_token:
            logging.error("Dropbox connection not configured - missing hostname or token")
            return jsonify({'success': False, 'error': 'Dropbox connection not configured'}), 400
        
        # Get Dropbox credentials
        url = f'https://{hostname}/api/v1/connection?include_secrets=true'
        headers = {
            'Accept': 'application/json',
            'X_REPLIT_TOKEN': x_replit_token
        }
        
        logging.info(f"Fetching Dropbox credentials from: {url}")
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        data = response.json()
        logging.info(f"Got response with {len(data.get('items', []))} items")
        
        # Find Dropbox connection
        dropbox_conn = None
        for item in data.get('items', []):
            logging.info(f"Checking item: {item.get('connector_name')} - {item.get('status')}")
            if item.get('connector_name') == 'dropbox' and item.get('status') == 'healthy':
                dropbox_conn = item
                break
        
        if not dropbox_conn:
            logging.error("No healthy Dropbox connection found")
            return jsonify({'success': False, 'error': 'Dropbox connection not available'}), 400
        
        logging.info("Found Dropbox connection, extracting access token...")
        oauth_creds = dropbox_conn.get('settings', {}).get('oauth', {}).get('credentials', {})
        access_token = oauth_creds.get('access_token')
        refresh_token = oauth_creds.get('refresh_token')
        
        if not access_token:
            logging.error("No access token found in Dropbox connection")
            return jsonify({'success': False, 'error': 'No access token'}), 400
        
        logging.info("Access token retrieved successfully")
        
        import dropbox
        
        # Download file from Dropbox
        dropbox_path = "/EPLATTFORMA SHARED FILES/EPLATTFORMA BI/EPLATTFORMA NEW DW/DATA/SerialsStockPositionReport1.xlsx"
        
        try:
            logging.info(f"Attempting to download from Dropbox: {dropbox_path}")
            dbx = dropbox.Dropbox(oauth2_access_token=access_token)
            result = dbx.files_download(dropbox_path)
            if not result:
                raise Exception("Failed to download file from Dropbox: empty response")
            response = result[1]
            file_data = response.content
            logging.info(f"Successfully downloaded file, size: {len(file_data)} bytes")
        except Exception as auth_err:
            logging.error(f"Dropbox auth error: {auth_err}")
            error_str = str(auth_err)
            if 'expired_access_token' in error_str:
                raise Exception("Your Dropbox connection has expired. Please go to the Replit Integrations panel, disconnect Dropbox, and reconnect it to refresh your access.")
            else:
                raise Exception(f"Dropbox authentication failed: {error_str}")
        
        # Parse Excel file
        workbook = openpyxl.load_workbook(BytesIO(file_data))
        worksheet = workbook.active
        
        if worksheet is None:
            raise Exception("No worksheet found in workbook")
        rows = list(worksheet.iter_rows(min_row=5, values_only=True))  # type: ignore
        records_to_insert = []
        current_item = None
        current_item_code = None
        current_store_code = None
        current_store_name = None
        
        for row in rows:
            # Skip empty rows
            if not any(row):
                continue
            
            # Item header row: Column A has value (item code - description)
            if row[0] and not row[1] and not row[2]:
                # Parse item code and description
                item_text = str(row[0]).strip()
                if ' - ' in item_text:
                    parts = item_text.split(' - ', 1)
                    current_item_code = parts[0].strip()
                    current_item = parts[1].strip()
                else:
                    current_item_code = item_text
                    current_item = item_text
                current_store_code = None
                current_store_name = None
                continue
            
            # Store header row: Column A is None, Column B has store code, Column C has store name
            if not row[0] and row[1] and row[2]:
                current_store_code = str(row[1]).strip() if row[1] else None
                current_store_name = str(row[2]).strip() if row[2] else None
                # Skip stores other than 777
                if current_store_code != "777":
                    current_store_code = None
                    current_store_name = None
                continue
            
            # Expiry/stock row: Column A and B are None, Column E has expiry date, Column G has stock
            if not row[0] and not row[1] and current_item_code and current_store_code and current_store_code == "777":
                expiry = row[4] if len(row) > 4 else None  # Column E
                stock = row[6] if len(row) > 6 else 0      # Column G
                
                expiry_str = None
                if expiry:
                    try:
                        if hasattr(expiry, 'strftime'):
                            expiry_str = expiry.strftime('%Y-%m-%d')
                        else:
                            expiry_str = str(expiry)
                    except:
                        pass
                
                try:
                    stock_val = float(stock) if stock else 0
                    records_to_insert.append({
                        'item_code': current_item_code,
                        'item_description': current_item,
                        'store_code': current_store_code,
                        'store_name': current_store_name,
                        'expiry_date': expiry_str,
                        'stock_quantity': stock_val,
                        'imported_at': datetime.utcnow()
                    })
                except (ValueError, TypeError):
                    pass
        
        # Delete existing records and insert new ones (bulk operation to prevent timeout)
        db.session.execute(text('TRUNCATE TABLE stock_positions'))
        
        # Insert in batches of 1000 to prevent memory issues
        for i in range(0, len(records_to_insert), 1000):
            batch = records_to_insert[i:i+1000]
            db.session.execute(
                text('INSERT INTO stock_positions (item_code, item_description, store_code, store_name, expiry_date, stock_quantity, imported_at) VALUES (:item_code, :item_description, :store_code, :store_name, :expiry_date, :stock_quantity, :imported_at)'),
                batch
            )
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Imported {len(records_to_insert)} stock records',
            'count': len(records_to_insert)
        })
    
    except Exception as e:
        db.session.rollback()
        logging.error(f'Stock refresh error: {str(e)}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/upload-stock-position', methods=['POST'])
@login_required
def upload_stock_position():
    """Import stock position data from manually uploaded Excel file"""
    if current_user.role not in ['admin', 'warehouse_manager']:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        import openpyxl
        from io import BytesIO
        from sqlalchemy import text
        
        if 'file' not in request.files:
            return jsonify({'success': False, 'error': 'No file provided'}), 400
        
        file = request.files['file']
        if file.filename == '':
            return jsonify({'success': False, 'error': 'No file selected'}), 400
        
        if not file.filename or not file.filename.endswith(('.xlsx', '.xls')):
            return jsonify({'success': False, 'error': 'Only Excel files (.xlsx, .xls) are supported'}), 400
        
        logging.info(f"Uploading stock position file: {file.filename}")
        
        # Read the uploaded file
        file_data = file.read()
        workbook = openpyxl.load_workbook(BytesIO(file_data))
        worksheet = workbook.active
        
        if worksheet is None:
            return jsonify({'success': False, 'error': 'No worksheet found in file'}), 400
        rows = list(worksheet.iter_rows(min_row=5, values_only=True))  # type: ignore
        records_to_insert = []
        current_item = None
        current_item_code = None
        current_store_code = None
        current_store_name = None
        
        for row in rows:
            # Skip empty rows
            if not any(row):
                continue
            
            # Item header row: Column A has value (item code - description)
            if row[0] and not row[1] and not row[2]:
                # Parse item code and description
                item_text = str(row[0]).strip()
                if ' - ' in item_text:
                    parts = item_text.split(' - ', 1)
                    current_item_code = parts[0].strip()
                    current_item = parts[1].strip()
                else:
                    current_item_code = item_text
                    current_item = item_text
                current_store_code = None
                current_store_name = None
                continue
            
            # Store header row: Column A is None, Column B has store code, Column C has store name
            if not row[0] and row[1] and row[2]:
                current_store_code = str(row[1]).strip() if row[1] else None
                current_store_name = str(row[2]).strip() if row[2] else None
                # Skip stores other than 777
                if current_store_code != "777":
                    current_store_code = None
                    current_store_name = None
                continue
            
            # Expiry/stock row: Column A and B are None, Column E has expiry date, Column G has stock
            if not row[0] and not row[1] and current_item_code and current_store_code and current_store_code == "777":
                expiry = row[4] if len(row) > 4 else None  # Column E
                stock = row[6] if len(row) > 6 else 0      # Column G
                
                expiry_str = None
                if expiry:
                    try:
                        if hasattr(expiry, 'strftime'):
                            expiry_str = expiry.strftime('%Y-%m-%d')
                        else:
                            expiry_str = str(expiry)
                    except:
                        pass
                
                try:
                    stock_val = float(stock) if stock else 0
                    records_to_insert.append({
                        'item_code': current_item_code,
                        'item_description': current_item,
                        'store_code': current_store_code,
                        'store_name': current_store_name,
                        'expiry_date': expiry_str,
                        'stock_quantity': stock_val,
                        'imported_at': datetime.utcnow()
                    })
                except (ValueError, TypeError):
                    pass
        
        # Delete existing records and insert new ones (bulk operation to prevent timeout)
        db.session.execute(text('TRUNCATE TABLE stock_positions'))
        
        # Insert in batches of 1000 to prevent memory issues
        for i in range(0, len(records_to_insert), 1000):
            batch = records_to_insert[i:i+1000]
            db.session.execute(
                text('INSERT INTO stock_positions (item_code, item_description, store_code, store_name, expiry_date, stock_quantity, imported_at) VALUES (:item_code, :item_description, :store_code, :store_name, :expiry_date, :stock_quantity, :imported_at)'),
                batch
            )
        
        db.session.commit()
        logging.info(f"Successfully imported {len(records_to_insert)} stock records from uploaded file")
        
        return jsonify({
            'success': True,
            'message': f'Imported {len(records_to_insert)} stock records',
            'count': len(records_to_insert)
        })
    
    except Exception as e:
        db.session.rollback()
        logging.error(f'Stock file upload error: {str(e)}')
        return jsonify({'success': False, 'error': str(e)}), 500


# Import time analysis routes
import routes_time_analysis  # noqa: F401

# Import shift tracking routes
from routes_shifts import *
